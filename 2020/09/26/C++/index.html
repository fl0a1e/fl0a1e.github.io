<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++学习笔记 | 时光琥珀</title><meta name="author" content="庄生晓梦"><meta name="copyright" content="庄生晓梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.基础格式 头文件不用加后缀，如#include&lt;iostream&gt; 头文件的后缀.h、.hpp、.hxx 源文件的后缀.cpp、.cxx、.cc &lt;&lt;流插入操作符，c里面是位操作符但这里含义变了，这个叫做运算符重载 IDE中是自动将制表符替换为4个空格 函数必须将返回值明确列出，不写的话编辑器默认返回int main函数不写return的话，会自动返回一个int值  命">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="http://example.com/2020/09/26/C++/index.html">
<meta property="og:site_name" content="时光琥珀">
<meta property="og:description" content="1.基础格式 头文件不用加后缀，如#include&lt;iostream&gt; 头文件的后缀.h、.hpp、.hxx 源文件的后缀.cpp、.cxx、.cc &lt;&lt;流插入操作符，c里面是位操作符但这里含义变了，这个叫做运算符重载 IDE中是自动将制表符替换为4个空格 函数必须将返回值明确列出，不写的话编辑器默认返回int main函数不写return的话，会自动返回一个int值  命">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/iimmgg/wallhaven-kw6v96.jpg">
<meta property="article:published_time" content="2020-09-26T14:21:53.000Z">
<meta property="article:modified_time" content="2023-10-23T10:14:16.054Z">
<meta property="article:author" content="庄生晓梦">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/iimmgg/wallhaven-kw6v96.jpg"><link rel="shortcut icon" href="/./iimmgg/icon.png"><link rel="canonical" href="http://example.com/2020/09/26/C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-23 18:14:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="时光琥珀" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://thirdqq.qlogo.cn/g?b=sdk&amp;k=q5qVDcvyzxee4qiays52mibA&amp;s=640" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friends</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./iimmgg/wallhaven-kw6v96.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="时光琥珀"><img class="site-icon" src="/./iimmgg/icon.png"/><span class="site-name">时光琥珀</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friends</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-26T14:21:53.000Z" title="Created 2020-09-26 22:21:53">2020-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-10-23T10:14:16.054Z" title="Updated 2023-10-23 18:14:16">2023-10-23</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li>头文件不用加后缀，如<code>#include&lt;iostream&gt;</code></li>
<li>头文件的后缀<code>.h</code>、<code>.hpp</code>、<code>.hxx</code></li>
<li>源文件的后缀<code>.cpp</code>、<code>.cxx</code>、<code>.cc</code></li>
<li><code>&lt;&lt;</code>流插入操作符，c里面是位操作符但这里含义变了，这个叫做<strong>运算符重载</strong></li>
<li>IDE中是自动将制表符替换为4个空格</li>
<li>函数必须将返回值明确列出，不写的话编辑器默认返回int</li>
<li>main函数不写return的话，会自动返回一个int值</li>
</ul>
<h3 id="命名空间-名字空间"><a href="#命名空间-名字空间" class="headerlink" title="命名空间&#x2F;名字空间"></a>命名空间&#x2F;名字空间</h3><p>不使用<code>using namespace std;</code>因为会导致不同命名空间中同名的在代码中使用时遇到冲突</p>
<p>最好用类似<code>std::cout&lt;&lt;&quot;Hello&quot;&lt;&lt;std::endl</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line">....</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>名字空间可以嵌套声明<br>可以定义自己的名字空间类似<code>namespace Myname&#123;......&#125;</code></p>
<p>名字空间的函数在外部不可见，名字空间的一个作用是<strong>隔离标识符的作用范围</strong></p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><table>
<thead>
<tr>
<th>英</th>
<th>中</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Error</td>
<td>语法错误</td>
</tr>
<tr>
<td>Runtime Error</td>
<td>运行时错误</td>
</tr>
<tr>
<td>Logic Error</td>
<td>逻辑错误</td>
</tr>
</tbody></table>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>()	<span class="comment">/*读一个字符*/</span></span><br><span class="line">cin.<span class="built_in">getline</span>()	<span class="comment">/*读到行尾或指定分隔符*/</span></span><br><span class="line">cin.<span class="built_in">ignore</span>()	<span class="comment">/*读取并舍弃指定数量的字符*/</span></span><br><span class="line">cout.<span class="built_in">put</span>()	<span class="comment">/*字符写入*/</span></span><br><span class="line">cout.<span class="built_in">flush</span>()	<span class="comment">/*缓冲区的内容全部输出*/</span></span><br></pre></td></tr></table></figure>

<h1 id="2-C的增强和C-特性"><a href="#2-C的增强和C-特性" class="headerlink" title="2.C的增强和C++特性"></a>2.C的增强和C++特性</h1><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>和函数的传参和指针联系在一起</p>
<p>要有本体，引用必须在声明的时候初始化，引用一旦初始化，引用名字就不能再指定给其它变量</p>
<p><strong>对引用的操作是作用在原变量上</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明引用类型变量*/</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span>&amp; rx = x;</span><br><span class="line"><span class="comment">/*一行内*/</span></span><br><span class="line"><span class="type">int</span> x, &amp;rx = x;</span><br></pre></td></tr></table></figure>

<p><strong>声明指针和引用时，*和&amp;要靠近类型而非变量名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* x;	<span class="comment">//Not float *x;</span></span><br><span class="line"><span class="type">int</span>&amp; y;	<span class="comment">//Not int &amp;y</span></span><br></pre></td></tr></table></figure>
<p>引用是在编译的过程中被处理的，实际上就是在编译层面对程序员进行的一个比较<strong>友好的语法</strong>，而在实现上是由编译器完成了地址的传递，<strong>实质上还是指针</strong></p>
<p>不能简单的理解为一个别名，我们可以这样用，但是要知道底层就是一个指针变量，是要占用内存空间的，和define是不一样的</p>
<h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>将引用放在形参的位置，在调用时只需要传递普通变量即可</p>
<p><strong>在被调函数中改变引用的值，原变量也发生变化</strong></p>
<h1 id="3-空指针和动态内存分配"><a href="#3-空指针和动态内存分配" class="headerlink" title="3.空指针和动态内存分配"></a>3.空指针和动态内存分配</h1><p>c++11标准引入一个保留字<code>nullptr</code>作为空指针，这样空指针就成为了一个确定的东西</p>
<h3 id="C-中通过运算符new申请动态内存"><a href="#C-中通过运算符new申请动态内存" class="headerlink" title="C++中通过运算符new申请动态内存"></a>C++中通过运算符new申请动态内存</h3><ol>
<li><strong>new</strong> &lt;类型名&gt; (初值) ;   &#x2F;&#x2F;申请一个变量的空间</li>
<li><strong>new</strong> &lt;类型名&gt;[常量表达式] ;  &#x2F;&#x2F;申请数组</li>
</ol>
<blockquote>
<p>如果申请成功，返回指定类型内存的地址；<br>如果申请失败，抛出异常，或者返回空指针(nullptr)。(C++11)</p>
</blockquote>
<h3 id="动态内存使用完毕后，要用delete运算符来释放"><a href="#动态内存使用完毕后，要用delete运算符来释放" class="headerlink" title="动态内存使用完毕后，要用delete运算符来释放"></a>动态内存使用完毕后，要用delete运算符来释放</h3><ol>
<li><strong>delete</strong>  &lt;指针名&gt;;  &#x2F;&#x2F;删除一个变量&#x2F;对象</li>
<li><strong>delete</strong> [] &lt;指针名&gt;;   &#x2F;&#x2F;删除数组空间</li>
</ol>
<h3 id="new-delete和malloc-free区别"><a href="#new-delete和malloc-free区别" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free区别"></a>new&#x2F;delete和malloc&#x2F;free区别</h3><ol>
<li>new&#x2F;delete是c++中的保留字，不需要头文件，相反，macoll&#x2F;free在c语言中，需要头文件的支持</li>
<li>new&#x2F;delete可以执行构造函数，而macoll却不可以执行</li>
<li>new&#x2F;delete可以自动判断字节大小，macoll必须自己指定大小；</li>
<li>macoll的返回值是void<em>，因此在使用的时候必须进行强类型转换，比如说使用macoll申请一个int类型的空间就需要：(int</em>)macoll（sizeodf（int）),而在new中，则不需要这些东西；</li>
<li>安全问题：new是安全的，会自己<strong>检测指针是否已经初始化</strong>，而macoll不会进行这样的判断</li>
<li>返回值问题：macoll的返回值，如果申请成功 就会返回已经申请的内存地址，若申请失败，将会返回空指针：NULL在new中，若申请失败，还可以发出异常</li>
<li>对象方面:delete会自己析构函数，但是free却不能完成。new在为对象申请时，可以自己执行构造函数，macoll却不能，如果是用户自定义的对象，macoll不行去申请地址。</li>
<li>相比之下：new&#x2F;delete更像是macoll&#x2F;free的增强版，但是消耗的的系统资源也会更多</li>
</ol>
<h1 id="4-bool，列表初始化，强制类型转换"><a href="#4-bool，列表初始化，强制类型转换" class="headerlink" title="4.bool，列表初始化，强制类型转换"></a>4.bool，列表初始化，强制类型转换</h1><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>其他和c一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一般以is开头*/</span></span><br><span class="line"><span class="type">bool</span>  isMyBook;</span><br><span class="line"><span class="type">bool</span>  isRunning = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//C++11 列表初始化方式</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">isBoy</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="comment">/*也有特殊情况*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span>   <span class="title">hasLicense</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>   <span class="title">canWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span>   <span class="title">shouldSort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> isAlpha;</span><br><span class="line">    isAlpha = <span class="literal">false</span>;    </span><br><span class="line">    <span class="keyword">if</span> (!isAlpha) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;isAlpha=&quot;</span> &lt;&lt; isAlpha &lt;&lt; std::endl;</span><br><span class="line">       std::cout &lt;&lt; std::boolalpha &lt;&lt;	<span class="comment">/*std::boolalpha输出bool类型*/</span></span><br><span class="line">              <span class="string">&quot;isAlpha=&quot;</span> &lt;&lt; isAlpha &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>能用列表初始化就用列表初始化**，因为不允许窄化，即不允许在赋值时隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*C++11标准之前的初始化方法*/</span></span><br><span class="line"><span class="comment">/*C++11标准仍然支持旧的初始化方法*/</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">c</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接列表初始化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variable initialization */</span> </span><br><span class="line"><span class="type">int</span> x&#123;&#125;; <span class="comment">// x is 0; </span></span><br><span class="line"><span class="type">int</span> y&#123; <span class="number">1</span> &#125;; <span class="comment">// y is 1; </span></span><br><span class="line"><span class="comment">/* Array initialization */</span> </span><br><span class="line"><span class="type">int</span> array1[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; </span><br><span class="line"><span class="type">char</span> s1[ <span class="number">3</span> ] &#123; <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;k&#x27;</span> &#125;; </span><br><span class="line"><span class="type">char</span> s3[]&#123; <span class="string">&quot;Hello&quot;</span> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝列表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variable initialization */</span> </span><br><span class="line"><span class="type">int</span> z = &#123; <span class="number">2</span> &#125;; </span><br><span class="line"><span class="comment">/* Array initialization */</span> </span><br><span class="line"><span class="type">int</span> array2[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="type">char</span> s2[] = &#123; <span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span> &#125;; </span><br><span class="line"><span class="type">char</span> s4[] = &#123; <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line"><span class="type">char</span> s5[] = <span class="string">&quot;Aloha&quot;</span>; <span class="comment">// Omit curly braces (省略花括号)</span></span><br></pre></td></tr></table></figure>



<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>类型转换必须显式声明。永远不要依赖隐式类型转换</strong></p>
<p>语法：<code>static_cast&lt;type&gt; value</code></p>
<h1 id="5-c-自动类型推导"><a href="#5-c-自动类型推导" class="headerlink" title="5.c++自动类型推导"></a>5.c++自动类型推导</h1><ul>
<li><p>auto 变量必须在定义时<strong>初始化</strong></p>
</li>
<li><p>C++14中，auto可以作为函数的返回值类型和参数类型</p>
</li>
</ul>
<p>定义在一个auto序列的变量必须始终推导成同一类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a4 = <span class="number">10</span>, a5&#123;<span class="number">20</span>&#125;;   <span class="comment">//正确 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b4&#123;<span class="number">10</span>&#125;, b5 = <span class="number">20.0</span>; <span class="comment">//错误,没有推导为同一类型</span></span><br></pre></td></tr></table></figure>

<p>如果初始化表达式是引用或const，则去除引用或const语义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;; <span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = b;   <span class="comment">//c的类型为int而非int&amp;（去除引用）</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a1&#123;<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b1 = a1; <span class="comment">//b1的类型为int而非const int（去除const） </span></span><br></pre></td></tr></table></figure>

<p>如果auto关键字带上&amp;号，则不去除引用或const语意</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="type">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; d = b;<span class="comment">//此时d的类型才为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; b2 = a2;<span class="comment">//因为auto带上&amp;，故不去除const，b2类型为const in</span></span><br></pre></td></tr></table></figure>

<p>初始化表达式为数组时，auto关键字推导类型为指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a3[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b3 = a3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b3).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//输出int * （输出与编译器有关）</span></span><br></pre></td></tr></table></figure>

<p>若表达式为数组且auto带上&amp;，则推导类型为数组类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a7[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; b7 = a7;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(b7).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//输出int [3] （输出与编译器有关）</span></span><br></pre></td></tr></table></figure>

<p><strong>decltype</strong> 主要用于<strong>泛型编程</strong>（模板）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">fun1</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="number">10</span>;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun2</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;g&#x27;</span>; &#125;  <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Data type of x is same as return type of fun1()</span></span><br><span class="line">    <span class="comment">// and type of y is same as return type of fun2()</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">fun1</span>()) x;  <span class="comment">// 不会执行fun1()函数</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">fun2</span>()) y = <span class="built_in">fun2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-内存模型"><a href="#6-内存模型" class="headerlink" title="6.内存模型"></a>6.内存模型</h1><ul>
<li>常量区（只读区）</li>
<li>全局变量区</li>
<li>堆区（放程序员自己分配的空间）（低地址到高地址）</li>
<li>栈区（函数的局部变量）（高地址到低地址）</li>
</ul>
<h1 id="7-常量和指针"><a href="#7-常量和指针" class="headerlink" title="7.常量和指针"></a>7.常量和指针</h1><h3 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h3><p>常量是程序中一块数据，这个数据一旦声明后就不能被修改了，修改报错</p>
<p>如果这块数据有一个名字，这个名字叫做<strong>命名常量</strong>；比如 const int A &#x3D; 42; 其中A就是命名常量；</p>
<p>如果这块数据（这个常量）从字面上看就能知道它的值，那它叫做<strong>“字面常量”</strong>，比如上面例子中的“42”就是字面常量</p>
<p>代码规范：符号常量(包括枚举值)必须全部大写并用下划线分隔单词。例如：MAX_ITERATIONS, COLOR_RED, PI</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> y = &#123; <span class="number">42</span> &#125;;  <span class="comment">// 这个在C++中叫做常量，在编译期就确定了值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = x;       <span class="comment">// z也是常量，在运行期才能确定值。</span></span><br><span class="line">y = <span class="number">42</span> + <span class="number">1</span>;            <span class="comment">// 不允许</span></span><br><span class="line">z ++;                  <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1;</span><br><span class="line"></span><br><span class="line">p1 = &amp;x;      <span class="comment">//指针 p1的类型是  (const int*)</span></span><br><span class="line">*p1 = <span class="number">10</span>;     <span class="comment">// Error!</span></span><br><span class="line"><span class="type">char</span>*        s1 = <span class="string">&quot;Hello&quot;</span>;     <span class="comment">// Error!</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s2 = <span class="string">&quot;Hello&quot;</span>;     <span class="comment">// Correct!</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2 = &amp;x; <span class="comment">//常量 p2的类型是  (int*)</span></span><br><span class="line"></span><br><span class="line">*p2 = <span class="number">10</span>;     <span class="comment">// Okay! à x=10</span></span><br><span class="line">p2 = &amp;y;      <span class="comment">// Error! p2 is a constant</span></span><br></pre></td></tr></table></figure>

<p><code>*</code>（指针）和 <code>const</code>（常量） 谁在前先读谁 ；<code>*</code> 代表被指的数据，名字代表指针地址</p>
<p><code>const</code>在谁前面谁就不允许改变</p>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ConstPointer = <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *;</span><br><span class="line">ConstPointer p;</span><br><span class="line">ConstPointer q;</span><br><span class="line">ConstPointer r;</span><br></pre></td></tr></table></figure>

<h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><p>形式： void fun() const {}      </p>
<p>构造函数和析构函数不可以是常函数      </p>
<p>特点：①可以使用数据成员，不能进行修改，对函数的功能有更明确的限定；            </p>
<p>②常对象只能调用常函数，不能调用普通函数；           </p>
<p>③常函数的this指针是const CStu*</p>
<h1 id="8-对象和类"><a href="#8-对象和类" class="headerlink" title="8.对象和类"></a>8.对象和类</h1><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><p>面向对象（Object-Oriented）</p>
<p>对象是一个独一无二的实体</p>
<hr>
<p>Abstraction（抽象）</p>
<p>Polymorphism（多态）</p>
<p>inheritance（继承）</p>
<p>Encapsulation（封装）</p>
<hr>
<p>对象有唯一标识，状态和行为</p>
<p>标识：只有一个名字</p>
<p>状态state：数据域</p>
<p>行为behavior：一组函数定义</p>
<hr>
<p>对象是类（class）的实例（instance）</p>
<p>类同样包含<strong>数据域</strong>和<strong>函数域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C ca, cb;	<span class="comment">//C是一种自定义的类型</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊函数</strong></p>
<p>构造函数（ctor）：在创建<strong>对象</strong>时被自动调用</p>
<p>析构函数（dtor）：在<strong>对象</strong>被销毁时被自动调用</p>
<h3 id="构造类"><a href="#构造类" class="headerlink" title="构造类"></a>构造类</h3><p>类中的东西有<strong>公有、私有</strong>之分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">/*公有*/</span></span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="built_in">Circle</span>()&#123;</span><br><span class="line">        radius = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r)&#123;</span><br><span class="line">        radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    Circle c2&#123;<span class="number">2.0</span>&#125;; <span class="comment">//用2.0作为参数去调用class的构造函数</span></span><br><span class="line">    std::cout &lt;&lt; c1.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; c2.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象拷贝和声明实现分离"><a href="#对象拷贝和声明实现分离" class="headerlink" title="对象拷贝和声明实现分离"></a>对象拷贝和声明实现分离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Circle c1;      <span class="comment">//调用Circle的默认ctor</span></span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">c2</span><span class="params">(<span class="number">5.5</span>)</span></span>; <span class="comment">//调用Circle的有参ctor</span></span><br><span class="line"></span><br><span class="line">Circle c3&#123;<span class="number">5.5</span>&#125;; <span class="comment">// 直接列表初始化,调有参ctor</span></span><br><span class="line"></span><br><span class="line">Circle c4 = &#123;<span class="number">5.5</span>&#125;; <span class="comment">// 拷贝列表初始化,调ctor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c5 = Circle&#123;<span class="number">2.</span>&#125;; <span class="comment">// auto类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(c1) c6;      <span class="comment">// decltype类型推断</span></span><br></pre></td></tr></table></figure>

<h4 id="成员拷贝"><a href="#成员拷贝" class="headerlink" title="成员拷贝"></a>成员拷贝</h4><p>How to copy the contents from one object to the other?(如何将一个对象的内容拷贝给另外一个对象)</p>
<p>(1)   use the assignment operator( 使用赋值运算符) ： &#x3D;</p>
<p>(2)   By default, <em><strong>each data field*</strong> of one object is copied to its counterpart in the other object. ( 默认情况下，对象中的每个</em>*数据域**都被拷贝到另一对象的对应部分)</p>
<p> <strong>函数成员没什么好拷贝的</strong></p>
<p>Example:  circle2 &#x3D; circle1;</p>
<p>(1)   将circle1 的radius 拷贝到circle2 中</p>
<p>(2)   拷贝后：circle1  和 circle2  是两个不同的对象，但是半径的值是相同的。( 但是各自有一个radius 成员变量)</p>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>Occasionally, you may create an object and <em>use it only once</em>. (有时需要创建一个只用一次的对象)</p>
<p>An object without name is called anonymous objects. (这种不命名的对象叫做匿名对象)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Circle c1 = Circle&#123;<span class="number">1.1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> c2 = Circle&#123;<span class="number">2.2</span>&#125;; <span class="comment">// 用匿名对象做拷贝列表初始化</span></span><br><span class="line"></span><br><span class="line">  Circle c3&#123;&#125;;           <span class="comment">// 直接列表初始化,调默认Ctor</span></span><br><span class="line"></span><br><span class="line">  c3 = Circle&#123;<span class="number">3.3</span>&#125;;      <span class="comment">// 用匿名对象赋值</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Area is &quot;</span> &lt;&lt; Circle&#123;<span class="number">4.2</span>&#125;.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Area is &quot;</span> &lt;&lt; <span class="built_in">Circle</span>().<span class="built_in">getArea</span>() &lt;&lt; endl;  <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Area is &quot;</span> &lt;&lt; <span class="built_in">Circle</span>(<span class="number">5</span>).<span class="built_in">getArea</span>() &lt;&lt; endl; <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h4><p>c语言的结构体默认公有</p>
<h4 id="罕见操作"><a href="#罕见操作" class="headerlink" title="罕见操作"></a>罕见操作</h4><p>局部类：函数中的类（很少用）</p>
<p>嵌套类：类中类（java比较喜欢）</p>
<h4 id="上机实验"><a href="#上机实验" class="headerlink" title="上机实验"></a>上机实验</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>() = <span class="keyword">default</span>; <span class="comment">//c++11 强制编译器生成一个默认构造函数</span></span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> side)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;side = side;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Square s1, s2&#123;<span class="number">4.0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; s1.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s2.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    s1 = s2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s1.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s2.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>()&#123;</span><br><span class="line">        balance = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Account</span>(<span class="type">double</span> balance_)&#123;<span class="comment">//不想用指针可以这样</span></span><br><span class="line">        balance = balance_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span></span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> temp&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(balance &lt; amount)&#123;</span><br><span class="line">            temp = balance;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Account a1;</span><br><span class="line">    Account a2 = Account&#123;<span class="number">100.0</span>&#125;;<span class="comment">//使用匿名对象，然后成员赋值</span></span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">deposit</span>(<span class="number">9.0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a1.<span class="built_in">withdraw</span>(<span class="number">10.0</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a2.<span class="built_in">withdraw</span>(<span class="number">50.00</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Account&#123;<span class="number">1000.0</span>&#125;.<span class="built_in">withdraw</span>(<span class="number">1001.0</span>) &lt;&lt; endl;<span class="comment">//一次性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h3><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><p>C++ allows you to separate class declaration from implementation. (C++中，类声明与实现可以分离)</p>
<p>(1)   .h:   类声明，描述类的结构</p>
<p>(2)   .cpp:  类实现，描述类方法的实现</p>
<p>FunctionType ClassName :: FunctionName (Arguments) { &#x2F;&#x2F;… }</p>
<p>其中，:: 这个运算符被称为binary scope resolution operator（二元作用域解析运算符），简称“域分隔符”</p>
<p>内联是为了在编译时会把函数体直接拷贝到调用位置，减少调用开销</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">//C++11</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;  <span class="comment">// f1自动称为内联函数</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">A::f2</span><span class="params">()</span> </span>&#123;  <span class="comment">// f2不是内联函数</span></span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">//C++11</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">A::f2</span><span class="params">()</span> </span>&#123;<span class="comment">//普通的函数实现</span></span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">A::f1</span><span class="params">()</span> </span>&#123; <span class="comment">// f1是内联函数</span></span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上机实验-1"><a href="#上机实验-1" class="headerlink" title="上机实验"></a>上机实验</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//系统提供</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    Circle c2&#123;<span class="number">2.0</span>&#125;; <span class="comment">//用2.0作为参数去调用class的构造函数</span></span><br><span class="line">    std::cout &lt;&lt; c1.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; c2.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLION_FUNCTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLION_FUNCTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>();</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius_);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLION_FUNCTION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>()&#123;</span><br><span class="line">    radius = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">double</span> radius_) &#123;</span><br><span class="line">    radius = radius_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Avoiding-Multiple-Inclusion-of-Header-Files"><a href="#Avoiding-Multiple-Inclusion-of-Header-Files" class="headerlink" title="Avoiding Multiple Inclusion of Header Files"></a>Avoiding Multiple Inclusion of Header Files</h4><p>C&#x2F;C++使用预处理指令(Preprocessing Directives)保证头文件只被包含&#x2F;编译一次</p>
<p>例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_FILE_H</span></span><br><span class="line"> <span class="comment">//  头文件内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>例2：</p>
<p>#pragma once    &#x2F;&#x2F; C++03, C90</p>
<p>例3</p>
<p>_Pragma(“once”) &#x2F;&#x2F; C++11, C99;</p>
<h1 id="对象指针，对象数组和函数参数"><a href="#对象指针，对象数组和函数参数" class="headerlink" title="对象指针，对象数组和函数参数"></a>对象指针，对象数组和函数参数</h1><h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><p>和c的结构体指针差不多</p>
<p>Object pointers can be assigned new object names(对象指针可以指向新的对象名)</p>
<p>Arrow operator -&gt; : Using pointer to access object members (箭头运算符 -&gt; ：用指针访问对象成员)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Circle circle1;</span><br><span class="line">Circle* pCircle = &amp;circle1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The radius is &quot;</span> &lt;&lt; (*pCircle).radius &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The area is &quot;</span> &lt;&lt; (*pCircle).<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">(*pCircle).radius = <span class="number">5.5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The radius is &quot;</span> &lt;&lt; pCircle-&gt;radius &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The area is &quot;</span> &lt;&lt; pCircle-&gt;<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>Object declared in a function is created in the stack.(在函数中声明的对象都在栈上创建)； When the function returns, the object is destroyed (函数返回，则对象被销毁).</p>
<p>Circle *****pCircle1 &#x3D; <strong>new</strong> Circle{}; &#x2F;&#x2F;用无参构造函数创建对象</p>
<p>Circle *****pCircle2 &#x3D; <strong>new</strong> Circle{5.9}; &#x2F;&#x2F;用有参构造函数创建对象</p>
<p>&#x2F;&#x2F;程序结束时，动态对象会被销毁，或者</p>
<p><strong>delete</strong> pObject; &#x2F;&#x2F;用delete显式销毁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> c1 = <span class="keyword">new</span> Circle&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    Circle c2&#123;<span class="number">2.0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pc2 = &amp;c2;</span><br><span class="line">    std::cout &lt;&lt; (*c1).<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; pc2-&gt;<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> c5 = <span class="keyword">new</span> Circle[<span class="number">3</span>]&#123;<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; c5[i].<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*c5是一个指针，基于范围的for循环无法使用</span></span><br><span class="line"><span class="comment">    for(auto x : c5)&#123;</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; x.getArea() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> c1;	<span class="comment">//自己创建的空间记得delete</span></span><br><span class="line">    <span class="keyword">delete</span> []c5;</span><br><span class="line">    c1 = c5 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> c1;  <span class="comment">//删除空指针不会出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>(1)   声明方式1</p>
<p>Circle ca1**[<strong>10</strong>];**</p>
<p>(2)   声明方式2</p>
<p>用匿名对象构成的列表初始化数组</p>
<p>Circle ca2**[<strong>3</strong>] &#x3D; { &#x2F;&#x2F; 注意：不可以写成： auto ca2[3]&#x3D;   因为声明数组时不能用auto**</p>
<p>​    Circle**{<strong>3</strong>},** </p>
<p>​    Circle**{ },** </p>
<p>​    Circle**{<strong>5</strong>} };** </p>
<p>(3)   声明方式3</p>
<p>用C++11列表初始化，列表成员为隐式构造的匿名对象</p>
<p>Circle ca3**[<strong>3</strong>] {** 3.1, {}, 5 <strong>};</strong></p>
<p>Circle ca4**[<strong>3</strong>] &#x3D; {** 3.1, {}, 5 <strong>};</strong> </p>
<p>(4)   声明方式4</p>
<p>用new在堆区生成对象数组</p>
<ol>
<li><strong>auto</strong>* p1 &#x3D; <strong>new</strong> Circle[3];</li>
<li><strong>auto</strong> p2 &#x3D; <strong>new</strong> Circle[3]{ 3.1, {}, 5 };</li>
<li><strong>delete</strong> [] p1;</li>
<li><strong>delete</strong> [] p2;</li>
<li>p1 &#x3D; p2 &#x3D; nullptr;</li>
</ol>
<hr>
<p>无法使用带圆括号的初始值设定项初始化数组，可以选择使用默认构造参数的方法，或者把（1.0）变成{1.0}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//系统提供</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle ca1[]&#123;Circle&#123;<span class="number">1.0</span>&#125;, Circle&#123;<span class="number">2.0</span>&#125;, Circle&#123;<span class="number">3.0</span>&#125;&#125;;<span class="comment">//原生数组不能用auto</span></span><br><span class="line">    Circle ca2[]&#123;<span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ca1[<span class="number">2</span>].<span class="built_in">setRadius</span>(<span class="number">4.0</span>);</span><br><span class="line">    ca2[<span class="number">0</span>].<span class="built_in">setRadius</span>(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> area1&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> area2&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(ca1)/<span class="built_in">sizeof</span>(ca1[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; ca1[i].<span class="built_in">getRadius</span>() &lt;&lt; std::endl;</span><br><span class="line">        area1 += ca1[i].<span class="built_in">getArea</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : ca2)&#123;</span><br><span class="line">        std::cout &lt;&lt; x.<span class="built_in">getRadius</span>() &lt;&lt; std::endl;</span><br><span class="line">        area2 += x.<span class="built_in">getArea</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLION_FUNCTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLION_FUNCTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>();</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius_);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> radius)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLION_FUNCTION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>()&#123;</span><br><span class="line">    radius = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">double</span> radius_) &#123;</span><br><span class="line">    radius = radius_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//常函数，const说明不能在函数内改变类的数据域即类的状态</span></span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::setRadius</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;radius = radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol>
<li>Objects as Function Arguments (对象作为函数参数)</li>
</ol>
<p>You can pass objects by value or by reference. (对象作为函数参数，可以按值传递也可以按引用传递)</p>
<p>(1)   Objects as Function Return Value(对象作为函数参数)</p>
<p>&#x2F;&#x2F; Pass by value</p>
<p>void print( <em>Circle</em> c ) {</p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<p> int main() {</p>
<p> Circle myCircle(5.0);</p>
<p> <em>print( myCircle );</em></p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<p>(2)   Objects Reference as Function Return Value(对象引用作为函数参数)</p>
<p>void print( <em>Circle&amp;</em> c ) {</p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<p> int main() {</p>
<p> Circle myCircle(5.0);</p>
<p> <em>print( myCircle );</em></p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<p>(3)   Objects Pointer as Function Return Value(对象指针作为函数参数)</p>
<p>&#x2F;&#x2F; Pass by pointer</p>
<p>void print( <em>Circle</em>* c ) {</p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<p> int main() {</p>
<p> Circle myCircle(5.0);</p>
<p> <em>print( &amp;myCircle );</em></p>
<p> &#x2F;* … *&#x2F;</p>
<p>}</p>
<ol start="2">
<li>Objects as Function Return Value(对象作为函数返回值)</li>
</ol>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>Object</strong> f <strong>(</strong> &#x2F;<em>函数形参</em>&#x2F; <strong>){</strong></p>
<p> &#x2F;&#x2F; Do something</p>
<p> <strong>return Object(args);</strong></p>
<p><strong>}</strong></p>
<p><strong>&#x2F;&#x2F; main() {</strong></p>
<p><strong>Object o &#x3D;</strong> f <strong>(</strong> &#x2F;<em>实参</em>&#x2F; <strong>);</strong></p>
<p>f**(** &#x2F;<em>实参</em>&#x2F; <strong>).memberFunction();</strong></p>
<ol start="3">
<li>Objects Pointer as Function Return Value(对象作为函数返回值)</li>
</ol>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>Object*</strong> f <strong>(</strong> &#x2F;<em>函数形参</em>&#x2F; <strong>){</strong></p>
<p> <strong>Object* o &#x3D; new Object(args) &#x2F;</strong>&#x2F; 这是“邪恶”的用法，不要这样做</p>
<p> &#x2F;&#x2F; Do something</p>
<p> <strong>return o;</strong></p>
<p><strong>}</strong></p>
<p><strong>&#x2F;&#x2F; main() {</strong></p>
<p><strong>Object* o &#x3D;</strong> f <strong>(</strong> &#x2F;<em>实参</em>&#x2F; <strong>);</strong></p>
<p>f**(** &#x2F;<em>实参</em>&#x2F; <strong>)-&gt;memberFunction();</strong></p>
<p>&#x2F;&#x2F; 记得要delete o</p>
<p>允许的用法</p>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>Object*</strong> f <strong>( Object* p,</strong> &#x2F;<em>其它形参</em>&#x2F; <strong>){</strong></p>
<p> &#x2F;&#x2F; Do something</p>
<p> <strong>return p;</strong></p>
<p><strong>}</strong></p>
<p><strong>&#x2F;&#x2F; main() {</strong></p>
<p><strong>Object* o &#x3D;</strong> f <strong>(</strong> &#x2F;<em>实参</em>&#x2F; <strong>);</strong></p>
<p>&#x2F;&#x2F; 不应该delete o</p>
<p>实践:</p>
<p>尽可能用const修饰函数返回值类型和参数除非你有特别的目的（使用移动语义等）。</p>
<p><em>const</em> Object* f(<em>const</em> Object* p, &#x2F;* 其它参数 *&#x2F;) { }</p>
<ol start="4">
<li>Objects Reference as Function Return Value(对象引用作为函数返回值)</li>
</ol>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>Object&amp;</strong> f <strong>(</strong> &#x2F;<em>函数形参</em>&#x2F; <strong>){</strong></p>
<p> <strong>Object o {args};</strong></p>
<p> &#x2F;&#x2F; Do something</p>
<p> <strong>return o;</strong>  &#x2F;&#x2F;这是邪恶的用法</p>
<p><strong>}</strong></p>
<p>可行的用法1</p>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>class X {</strong></p>
<p> <strong>Object o;</strong></p>
<p> Object f**(** &#x2F;<em>实参</em>&#x2F; <strong>){</strong></p>
<p>  &#x2F;&#x2F; Do something</p>
<p>  <strong>return o;</strong></p>
<p> <strong>}</strong></p>
<p><strong>}</strong></p>
<p>可行的用法2</p>
<p>&#x2F;&#x2F; class Object { … };</p>
<p><strong>Object&amp;</strong> f <strong>( Object&amp; p,</strong> &#x2F;<em>其它形参</em>&#x2F; <strong>){</strong></p>
<p> &#x2F;&#x2F; Do something</p>
<p> <strong>return p;</strong></p>
<p><strong>}</strong></p>
<p><strong>&#x2F;&#x2F; main() {</strong></p>
<p><strong>auto&amp; o &#x3D;</strong> f <strong>(</strong> &#x2F;<em>实参</em>&#x2F; <strong>);</strong></p>
<p>f**(** &#x2F;<em>实参</em>&#x2F; <strong>).memberFunction();</strong></p>
<p>实践:</p>
<p>用const修饰引用类型的函数返回值，除非你有特别目的（比如使用移动语义）</p>
<p><em>const</em> Object&amp; f( &#x2F;* args *&#x2F;) { }</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//系统提供</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"><span class="comment">/*放上去会有二义性</span></span><br><span class="line"><span class="comment">void print(Circle c)&#123;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; c.getArea() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Circle&amp; c)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; c.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Circle* c)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; c-&gt;<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle ca[]&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(ca[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">print</span>(ca[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">print</span>(ca+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，<strong>能用引用尽量不用指针</strong>。引用更加直观，更少出现意外的疏忽导致的错误。</p>
<p>指针可以有二重、三重之分，比引用更加灵活。有些情况下，例如使用 new 运算符，只能用指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//系统提供</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; c.<span class="built_in">setRadius</span>(<span class="number">2.0</span>).<span class="built_in">setRadius</span>(<span class="number">3.0</span>).<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLION_FUNCTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLION_FUNCTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>();</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> radius_);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">Circle&amp; <span class="title">setRadius</span><span class="params">(<span class="type">double</span> radius)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLION_FUNCTION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>   <span class="comment">//自定义的</span></span></span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>()&#123;</span><br><span class="line">    radius = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">double</span> radius_) &#123;</span><br><span class="line">    radius = radius_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Circle::getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//常函数，const说明不能在函数内改变类的数据域即类的状态</span></span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle&amp; <span class="title">Circle::setRadius</span><span class="params">(<span class="type">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;radius = radius;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象，封装和this指针"><a href="#抽象，封装和this指针" class="headerlink" title="抽象，封装和this指针"></a><strong>抽象，封装和this指针</strong></h1><p><strong>数据域采用public的形式有2个问题</strong></p>
<ol>
<li>数据会被类外的方法篡改</li>
<li>使得类难于维护，易出现bug</li>
</ol>
<p><strong>为了能在外部访问私有成员有了访问器和更改器</strong></p>
<p>getter and setter</p>
<p><strong>类抽象与封装</strong></p>
<p>抽象：在研究对象或系统时，为了更加专注于感兴趣的细节，去除对象或系统的物理或时空细节&#x2F; 属性的过程</p>
<p>封装：一种限制直接访问对象组成部分的语言机制;一种实现数据和函数绑定的语言构造块</p>
<h2 id="The-Scope-of-Data-Members-in-Class-数据成员的作用域"><a href="#The-Scope-of-Data-Members-in-Class-数据成员的作用域" class="headerlink" title="The Scope of Data Members in Class (数据成员的作用域)"></a>The Scope of Data Members in Class (数据成员的作用域)</h2><ol>
<li>数据成员可被类内所有函数访问</li>
<li>数据域与函数可按任意顺序声明</li>
</ol>
<h2 id="Hidden-by-same-name-同名屏蔽"><a href="#Hidden-by-same-name-同名屏蔽" class="headerlink" title="Hidden by same name (同名屏蔽)"></a>Hidden by same name (同名屏蔽)</h2><p>数据域成员的名字和类中函数内部的变量名相同，那么，就近原则，数据域成员被屏蔽</p>
<p>若要访问数据域成员使用关键字this</p>
<p><code>this-&gt;datanama</code></p>
<p>this特性：特殊的内建指针;引用当前函数的调用对象</p>
<p>避免的简单方法：函数参数设位<code>dataname_</code></p>
<h1 id="类数据成员的初始化"><a href="#类数据成员的初始化" class="headerlink" title="类数据成员的初始化"></a><strong>类数据成员的初始化</strong></h1><h2 id="基本初始化方法"><a href="#基本初始化方法" class="headerlink" title="基本初始化方法"></a>基本初始化方法</h2><ul>
<li>在C++03标准中，只有静态常量整型成员才能在类中就地初始化</li>
<li>C++11标准中，非静态成员可以在它声明的时候初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123; </span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m = <span class="number">7</span>; <span class="comment">// ok, copy-initializes m  </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(<span class="number">7</span>)</span></span>;  <span class="comment">// 错误：不允许用小括号初始化  </span></span><br><span class="line"></span><br><span class="line">  std::string s&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">// ok, direct list-initializes s</span></span><br><span class="line"></span><br><span class="line">  std::string t&#123;<span class="string">&quot;Constructor run&quot;</span>&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 错误：数组类型成员不能自动推断大小 </span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引用类型的成员有一些额外限制，参考标准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">S</span>() &#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类的初始化列表"><a href="#类的初始化列表" class="headerlink" title="类的初始化列表"></a>类的初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span> (parameterList)</span><br><span class="line"></span><br><span class="line">  : dataField1&#123;value1&#125;, dataField2&#123;value2&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Something to do </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>() : radius&#123;<span class="number">1</span>&#125;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这连个对基础类型效果相同*/</span></span><br><span class="line">Circle::<span class="built_in">Circle</span>()&#123;</span><br><span class="line">    radius = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>类的数据域是一个对象类型，被称为对象中的对象，或者内嵌对象</li>
<li>内嵌对象必须在被嵌对象的构造函数体执行前就构造完成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123; <span class="comment">/* Code omitted */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Action</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second) &#123;</span><br><span class="line"></span><br><span class="line">    time = <span class="built_in">Time</span>(hour, minute, second); <span class="comment">//time对象应该在构造函数体之前构造完成</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  Time time;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">Action <span class="title">a</span><span class="params">(<span class="number">11</span>, <span class="number">59</span>, <span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Default-Constructor-默认构造函数"><a href="#Default-Constructor-默认构造函数" class="headerlink" title="Default Constructor  默认构造函数"></a>Default Constructor  默认构造函数</h2><ul>
<li>默认构造函数是可以无参调用的构造函数，既可以是定义为空参数列表的构造函数，也可以是所有参数都有默认参数值的构造函数</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle1</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Circle1</span>() &#123;      <span class="comment">// 无参数</span></span><br><span class="line"></span><br><span class="line">    radius = <span class="number">1.0</span>; <span class="comment">/*函数体可为空*/</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle2</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Circle2</span>(<span class="type">double</span> r = <span class="number">1.0</span>) <span class="comment">// 所有参数都有默认值</span></span><br><span class="line"></span><br><span class="line">    : radius&#123; r &#125; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>若对象类型成员&#x2F;内嵌对象成员没有被显式初始化</li>
<li>该内嵌对象的无参构造函数会被自动调用</li>
<li>若内嵌对象没有无参构造函数，则编译器报错</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Circle c1;<span class="comment">/*内嵌对象*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Circle c1;<span class="comment">/*内嵌对象*/</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">/*或在创建被嵌对象时完成初始化*/</span></span><br><span class="line">    <span class="built_in">X</span>():c1&#123;&#125;&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="初始化次序"><a href="#初始化次序" class="headerlink" title="初始化次序"></a>初始化次序</h2><ul>
<li>执行次序</li>
</ul>
<p>就地初始化 &gt; Ctor初始化列表 &gt; Ctor函数体中为成员赋值</p>
<ul>
<li>优先次序</li>
</ul>
<p>Ctor函数体中为成员赋值 &gt; Ctor初始化列表 &gt; 就地初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n = ++x;            <span class="comment">// default initializer</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">S</span>() &#123; &#125;                 <span class="comment">// 使用就地初始化(default initializer)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">S</span>(<span class="type">int</span> arg) : <span class="built_in">n</span>(arg) &#123; &#125; <span class="comment">// 使用成员初始化列表</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">  S s1;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 1 (default initializer ran)</span></span><br><span class="line"></span><br><span class="line">  <span class="function">S <span class="title">s2</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 1 (default initializer did not run)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string类和std-array类"><a href="#string类和std-array类" class="headerlink" title="string类和std::array类"></a>string类和std::array类</h1><h2 id="The-C-string-Class"><a href="#The-C-string-Class" class="headerlink" title="The C++ string Class"></a>The C++ string Class</h2><ul>
<li>构造</li>
<li>追加</li>
<li>赋值</li>
<li>位置与清除</li>
<li>长度与容量</li>
<li>比较</li>
<li>子 串</li>
<li>搜索</li>
<li>运算符</li>
</ul>
<ol>
<li><strong>index:</strong> 从index号位置开始</li>
<li><strong>n:</strong> 之后的n个字符</li>
</ol>
<hr>
<ul>
<li>用无参构造函数创建一个空字串<code>string newString;</code></li>
<li>由一个字符串常量或字符串数组创建string对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string message&#123; <span class="string">&quot;Aloha World!&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> charArray[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">string message1&#123; charArray &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*追加*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s1.<span class="built_in">append</span>( <span class="string">&quot; to C++&quot;</span> ); <span class="comment">// appends &quot; to C++&quot; to s1</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// s1 now becomes Welcome to C++</span></span><br><span class="line">string s2&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s2.<span class="built_in">append</span>( <span class="string">&quot; to C and C++&quot;</span>, <span class="number">3</span>, <span class="number">2</span> ); <span class="comment">// appends &quot; C&quot; to s2</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; <span class="comment">// s2 now becomes Welcome C</span></span><br><span class="line">string s3&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s3.<span class="built_in">append</span>( <span class="string">&quot; to C and C++&quot;</span>, <span class="number">5</span>); <span class="comment">// appends &quot; to C&quot; to s3</span></span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl; <span class="comment">// s3 now becomes Welcome to C</span></span><br><span class="line">string s4&#123; <span class="string">&quot;Welcome&quot;</span> &#125;; </span><br><span class="line">s4.<span class="built_in">append</span>( <span class="number">4</span>, <span class="string">&#x27;G&#x27;</span> ); <span class="comment">// appends &quot;GGGG&quot; to s4</span></span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl; <span class="comment">// s4 now becomes WelcomeGGGG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*赋值*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s1.<span class="built_in">assign</span>( <span class="string">&quot;Dallas&quot;</span> ); <span class="comment">// assigns &quot;Dallas&quot; to s1</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// s1 now becomes Dallas</span></span><br><span class="line">string s2&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s2.<span class="built_in">assign</span>( <span class="string">&quot;Dallas, Texas&quot;</span>, <span class="number">1</span>, <span class="number">3</span> ); <span class="comment">// assigns &quot;all&quot; to s2</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; <span class="comment">// s2 now becomes all</span></span><br><span class="line">string s3&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s3.<span class="built_in">assign</span>( <span class="string">&quot;Dallas, Texas&quot;</span>, <span class="number">6</span> ); <span class="comment">// assigns &quot;Dallas&quot; to s3</span></span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl; <span class="comment">// s3 now becomes Dallas</span></span><br><span class="line">string s4&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">s4.<span class="built_in">assign</span>( <span class="number">4</span>, <span class="string">&#x27;G&#x27;</span> ); <span class="comment">// assigns &quot;GGGG&quot; to s4</span></span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl; <span class="comment">// s4 now becomes GGGG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能型*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at(index):  返回当前字符串中index位置的字符</span></span><br><span class="line"><span class="comment">clear(): 清空字符串</span></span><br><span class="line"><span class="comment">erase(index, n):  删除字符串从index开始的n个字符</span></span><br><span class="line"><span class="comment">empty(): 检测字符串是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// s1.at(3) returns c</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">erase</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// s1 is now Weme</span></span><br><span class="line">s1.<span class="built_in">clear</span>(); <span class="comment">// s1 is now empty</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">empty</span>() &lt;&lt; endl; <span class="comment">// s1.empty returns 1 (means true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比较*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">string s2&#123; <span class="string">&quot;Welcomg&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">compare</span>(s2) &lt;&lt; endl; <span class="comment">// returns -2</span></span><br><span class="line">cout &lt;&lt; s2.<span class="built_in">compare</span>(s1) &lt;&lt; endl; <span class="comment">// returns 2</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">compare</span>(<span class="string">&quot;Welcome&quot;</span>) &lt;&lt; endl; <span class="comment">// returns 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at() 函数用于获取一个单独的字符；</span></span><br><span class="line"><span class="comment">substr() 函数则可以获取一个子串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// returns W；  从0号位置开始的1个字符</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">substr</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// returns come；  从3号位置直到末尾的子串</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">substr</span>(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// returns com；从3号位置开始的3个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*搜索*/</span></span><br><span class="line">string s1&#123; <span class="string">&quot;Welcome to C++&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">&quot;co&quot;</span>) &lt;&lt; endl; <span class="comment">// returns 3； 返回子串出现的第一个位置</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">&quot;co&quot;</span>, <span class="number">6</span>) &lt;&lt; endl; <span class="comment">// returns -1 从6号位置开始查找子串出现的第一个位置</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>) &lt;&lt; endl; <span class="comment">// returns 4    返回字符出现的第一个位置</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">6</span>) &lt;&lt; endl; <span class="comment">// returns 9   从6号位置开始查找字符出现的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入和替换*/</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Welcome to C++&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;Java and &quot;</span>);</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// s1 becomes Welcome to Java and C++</span></span><br><span class="line">string s2&#123; <span class="string">&quot;AA&quot;</span> &#125;;</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">//在1号位置处连续插入4个相同字符</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; <span class="comment">// s2 becomes to ABBBBA</span></span><br><span class="line">string s3&#123; <span class="string">&quot;Welcome to Java&quot;</span> &#125;;</span><br><span class="line">s3.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">4</span>, <span class="string">&quot;C++&quot;</span>); <span class="comment">//从11号位置开始向后的4个字符替换掉。注意&#x27;\0&#x27;</span></span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl; <span class="comment">// returns Welcome to C++ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*运算符*/</span></span><br><span class="line">string s1 = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// The = operator</span></span><br><span class="line">string s2 = s1;    <span class="comment">// The = operator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    cout &lt;&lt; s2[i]; <span class="comment">// The [] operator</span></span><br><span class="line"></span><br><span class="line">string s3 = s1 + <span class="string">&quot;DEFG&quot;</span>; <span class="comment">// The + operator</span></span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl; <span class="comment">// s3 becomes ABCDEFG</span></span><br><span class="line"></span><br><span class="line">s1 += <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// s1 becomes ABCABC</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;ABE&quot;</span>;</span><br><span class="line">cout &lt;&lt; (s1 == s2) &lt;&lt; endl; <span class="comment">// Displays 0 </span></span><br><span class="line">cout &lt;&lt; (s1 != s2) &lt;&lt; endl; <span class="comment">// Displays 1 </span></span><br><span class="line">cout &lt;&lt; (s1 &gt;  s2) &lt;&lt; endl; <span class="comment">// Displays 0 </span></span><br><span class="line">cout &lt;&lt; (s1 &gt;= s2) &lt;&lt; endl; <span class="comment">// Displays 0 </span></span><br><span class="line">cout &lt;&lt; (s1 &lt;  s2) &lt;&lt; endl; <span class="comment">// Displays 1 </span></span><br><span class="line">cout &lt;&lt; (s1 &lt;= s2) &lt;&lt; endl; <span class="comment">// Displays 1 </span></span><br></pre></td></tr></table></figure>

<h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><ul>
<li><p>是一个容器类，所以有迭代器（可以认为是一种用于访问成员的高级指针）</p>
</li>
<li><p>可直接赋值</p>
</li>
<li><p>知道自己大小：size()</p>
</li>
<li><p>能和另一个数组交换内容：swap()</p>
</li>
<li><p>能以指定值填充自己: fill()</p>
</li>
<li><p>取某个位置的元素( 做越界检查) ：at()</p>
</li>
</ul>
<hr>
<p><strong>C++数组类是一个模板类，可以容纳任何类型的数据</strong></p>
<p>#include <array></p>
<p>std::array&lt; 数组 类型,  数组大小&gt;  数组名字;</p>
<p>std::array&lt; 数组 类型,  数组大小&gt;  数组 名字 { 值1,  值2, …};</p>
<p>限制与C风格数组相同</p>
<p>std::array&lt;int , 10&gt; x;</p>
<p>std::array&lt;char , 5&gt; c{ ‘H’,’e’,’l’,’l’,’o’ };</p>
<hr>
<p><strong>C++17引入了一种新特性，对类模板的参数进行推导 (学完模板才能看懂这句话)</strong></p>
<p>示例：</p>
<p>std::array a1 {1, 3, 5};      &#x2F;&#x2F; 推导出 std::array&lt;int, 3&gt;</p>
<p>std::array a2 {‘a’, ‘b’, ‘c’, ‘d’};  &#x2F;&#x2F; 推导出 std::array&lt;char, 4&gt;</p>
<h1 id="c-11断言和常量表达式"><a href="#c-11断言和常量表达式" class="headerlink" title="c++11断言和常量表达式"></a>c++11断言和常量表达式</h1><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><ul>
<li><p>常量表达式是编译期可以计算值的一个表达式</p>
</li>
<li><p>const 修饰的对象未必是编译期常量</p>
</li>
<li><h3 id="constexpr说明符声明可在编译时计算函数或变量的值"><a href="#constexpr说明符声明可在编译时计算函数或变量的值" class="headerlink" title="constexpr说明符声明可在编译时计算函数或变量的值"></a>constexpr说明符声明可在编译时计算函数或变量的值</h3></li>
</ul>
<hr>
<h2 id="断言与C-11的静态断言"><a href="#断言与C-11的静态断言" class="headerlink" title="断言与C++11的静态断言"></a>断言与C++11的静态断言</h2><ul>
<li>断言是一条检测假设成立与否的语句</li>
</ul>
<p>assert : C语言的宏(Macro)，运行时检测。</p>
<p><strong>用法：包含头文件 <cassert>  以调试模式编译程序</strong></p>
<p>assert( bool_expr ); &#x2F;&#x2F; bool_expr 为假则中断程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::array a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">//C++17 类型参数推导</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">assert</span>(i &lt; <span class="number">3</span>); <span class="comment">//断言：i必须小于3，否则失败</span></span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; a[ i ];</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; (i == a.<span class="built_in">size</span>() ? <span class="string">&quot;&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>assert()依赖于NDEBUG 宏 </p>
<p> NDEBUG这个宏是C&#x2F;C++标准规定的，所有编译器都有对它的支持。</p>
<p>(1)   调试(Debug)模式编译时，编译器不会定义NDEBUG，所以assert()宏起作用。</p>
<p>(2)   发行(Release)模式编译时，编译器自动定义宏NDEBUG，使assert不起作用</p>
<p>如果要强制使得assert()生效或者使得assert()不生效，只要手动 #define NDEBUG 或者 #undef NDEBUG即可。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NDEBUG  <span class="comment">// 强制以debug模式使用&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Enter an int: &quot;</span>;</span><br><span class="line"></span><br><span class="line"> std::cin &gt;&gt; i;</span><br><span class="line"></span><br><span class="line"> *<span class="built_in">assert</span>((i &gt; <span class="number">0</span>) &amp;&amp; <span class="string">&quot;i must be positive&quot;</span>);* </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面示例的第6行代码中，若assert中断了程序则表明程序出bug了！程序员要重编代码解决这个bug，而不是把assert()放在那里当成正常程序的一部分</p>
<hr>
<ul>
<li>《代码大全2》：若某些状况是你预期中的，那么用错误处理；若某些状况永不该发生，用断言</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n&#123; <span class="number">1</span> &#125; , m&#123; <span class="number">0</span> &#125;;</span><br><span class="line">std::cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">assert</span>((n != <span class="number">0</span>) &amp;&amp; <span class="string">&quot;Divisor cannot be zero!&quot;</span>); <span class="comment">// 不合适</span></span><br><span class="line"><span class="type">int</span> q = m / n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n&#123; <span class="number">1</span> &#125; , m&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;                <span class="comment">// 这是修补bug的代码</span></span><br><span class="line">  std::cin &gt;&gt; n;    <span class="comment">// 断言失败后，要解决这个bug</span></span><br><span class="line">&#125; <span class="keyword">while</span> (n == <span class="number">0</span>);   <span class="comment">// 在这里编写修复bug的代码</span></span><br><span class="line"><span class="built_in">assert</span>((n != <span class="number">0</span>) &amp;&amp; <span class="string">&quot;Divisor cannot be zero!&quot;</span>);</span><br><span class="line"><span class="type">int</span> q = m / n;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><ul>
<li><strong>“声明”</strong>是引入标识符并描述其类型，无论是类型，对象还是函数。编译器需要该“声明”，以便识别在它处使用该标识符</li>
<li><strong>“定义”</strong>实例化&#x2F;实现这个标识符。链接器需要“定义”，以便将对标识符的引用链接到标识符所表示的实体</li>
</ul>
<h1 id="代理构造"><a href="#代理构造" class="headerlink" title="代理构造"></a>代理构造</h1><ul>
<li>一个构造函数可以调用另外的构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">   <span class="built_in">A</span>(): <span class="built_in">A</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">      num1=i;</span><br><span class="line">      num2=j;</span><br><span class="line">      average=(num1+num2)/<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> num1;</span><br><span class="line">   <span class="type">int</span> num2;</span><br><span class="line">   <span class="type">int</span> average;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A()-&gt;A(int)-&gt;A(int, int)</p>
<ul>
<li>避免递归调用目标ctor</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">   <span class="built_in">A</span>(): <span class="built_in">A</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j): <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> num1;</span><br><span class="line">   <span class="type">int</span> num2;</span><br><span class="line">   <span class="type">int</span> average;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A()-&gt;A(int)-&gt;A(int, int)-&gt;A()</p>
<h1 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h1><ul>
<li>不可变对象:对象创建后，其内容不可改变，除非通过成员拷贝</li>
<li>不可变类 :不可变对象所属的类</li>
</ul>
<p> 删除set类型函数即可</p>
<hr>
<ul>
<li>另一种情况：指针成员</li>
</ul>
<hr>
<p><strong>让类成为“不可变类”</strong></p>
<ol>
<li>所有数据域均设置为“私有”属性</li>
<li>没有更改器函数</li>
<li>也没有能够返回可变数据域对象的<em>引用或指针</em>的访问器</li>
</ol>
<hr>
<ul>
<li><p>不可变对象至表示一个状态。所以线程安全没有同步问题</p>
</li>
<li><p>不可变对象更加易于设计、实现和使用</p>
</li>
<li><p>不可变对象是很优秀的Map key和Set element</p>
</li>
<li><p>不可变性使得编写、使用和解释代码很容易</p>
</li>
<li><p>不可变性是得并行变得容易，因为没有冲突</p>
</li>
<li><p>程序被状态不会发生改变，就算有异常发生</p>
</li>
<li><p>不可变对象的引用可以被缓</p>
</li>
</ul>
<h1 id="实例成员与静态成员"><a href="#实例成员与静态成员" class="headerlink" title="实例成员与静态成员"></a>实例成员与静态成员</h1><ul>
<li>在类定义中，关键字 static 声明 不绑定到类实例的成员( 该成员无需创建对象即可访问)</li>
</ul>
<hr>
<p><strong>静态数据成员</strong>具有静态存储期(static storage duration)或者C++11线程存储期特性</p>
<p><strong>静态存储期</strong>:对象的存储在程序开始时分配，而在程序结束时解回收</p>
<ul>
<li><p>只存在对象的一个实例</p>
</li>
<li><p>静态存储器对象未明确初始化时会被自动“零初始化(Zero-Initialization)”</p>
</li>
</ul>
<hr>
<p>在下面的例子中，一旦实例化了Square（创建了Square的对象），每个对象中都有各自的side成员。这个side成员就叫做实例成员</p>
<p>而numberOfObjects只存在一个，是由所有的Square对象共享的，叫做静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> side;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> numberOfObjects;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Square</span>():<span class="built_in">Square</span>(<span class="number">1.0</span>)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Square</span>(<span class="type">double</span> side)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;side = side;</span><br><span class="line">    numberOfObjects++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Square::numberOfObjects;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Square s1&#123;&#125;, s2&#123;<span class="number">5.0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h1><ul>
<li>对象销毁时自动调用</li>
<li>不带参数</li>
<li>不能有返回值</li>
<li>不能重载（因为无参）</li>
</ul>
<h1 id="友元（c-独有）"><a href="#友元（c-独有）" class="headerlink" title="友元（c++独有）"></a>友元（c++独有）</h1><p><strong>存在原因</strong>：私有成员无法从类外访问，但有时又需要授权某些可信的函数和类访问这些私有成员</p>
<p><strong>友元函数和友元类</strong>：用friend关键字声明友元函数或者友元类</p>
<p><strong>友元的缺点</strong>：打破了封装性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> year&#123; <span class="number">2019</span> &#125; , month&#123; <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="type">int</span> day&#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Kid</span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Date&amp; d)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Date&amp; d)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; d.year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; d.month </span><br><span class="line">       &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; d.day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kid</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Date birthday;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Kid</span>() &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I was born in &quot;</span> </span><br><span class="line">         &lt;&lt; birthday.year &lt;&lt; endl; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">Date</span>());</span><br><span class="line">  Kid k;</span><br><span class="line">  cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p><strong>拷贝构造</strong>：用一个对象初始化另一个同类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="built_in">Circle</span> (Circle&amp;);</span><br><span class="line"><span class="built_in">Circle</span> (<span class="type">const</span> Circle&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">( <span class="number">5.0</span> )</span></span>; </span><br><span class="line"><span class="function">Circle <span class="title">c2</span><span class="params">( c1 )</span></span>;    <span class="comment">//c++03</span></span><br><span class="line">Circle c3 = c1;     <span class="comment">//c++03</span></span><br><span class="line">Circle c4 = &#123; c1 &#125;; <span class="comment">//c++11</span></span><br><span class="line">Circle c5&#123; c1 &#125;;    <span class="comment">//c++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*带有额外的默认参数的拷贝构造函数*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;  <span class="comment">//来自C++11标准: 12.8节</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">const</span> X&amp;, <span class="type">int</span> = <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">X <span class="title">b</span><span class="params">(a, <span class="number">0</span>)</span></span>; <span class="comment">// calls X(const X&amp;, int);</span></span><br><span class="line">X c = b;   <span class="comment">// calls X(const X&amp;, int);</span></span><br></pre></td></tr></table></figure>

<p><strong>warning</strong>:两个对象obj1和obj2已经定义。然后这种形式的语句：</p>
<p>obj1 <strong>&#x3D;</strong> obj2;不是调用拷贝构造函数，而是对象赋值</p>
<p>拷贝构造要在定义时赋值</p>
<hr>
<h2 id="隐式声明的拷贝构造函数"><a href="#隐式声明的拷贝构造函数" class="headerlink" title="隐式声明的拷贝构造函数"></a>隐式声明的拷贝构造函数</h2><ul>
<li>一般情况下，如果程序员不编写拷贝构造函数，那么编译器会自动生成一个</li>
<li>自动生成的拷贝构造函数叫做“隐式声明&#x2F;定义的拷贝构造函数</li>
<li>一般情况下，隐式声明的copy ctor简单地将作为参数的对象中的每个<strong>数据域</strong>复制到新对象中</li>
</ul>
<hr>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><strong>拷贝指针指向的内容</strong></p>
<p>How：</p>
<ol>
<li>自行编写拷贝构造函数，不使用编译器隐式生成的（默认）拷贝构造函数</li>
<li>重载赋值运算符，不使用编译器隐式生成的（默认）赋值运算符函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Employee(const Employee &amp;e) = default; //浅拷贝ctor</span></span><br><span class="line">  <span class="built_in">Employee</span>(<span class="type">const</span> Employee&amp; e)&#123;    <span class="comment">//深拷贝ctor</span></span><br><span class="line">    birthdate = <span class="keyword">new</span> Date&#123; e.birthdate &#125;;</span><br><span class="line">  &#125; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Employee e1&#123;<span class="string">&quot;Jack&quot;</span>, <span class="built_in">Date</span>(<span class="number">1999</span>, <span class="number">5</span>, <span class="number">3</span>), Gender::male&#125;;</span><br><span class="line">Employee e2&#123;<span class="string">&quot;Anna&quot;</span>, <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">11</span>, <span class="number">8</span>),, Gender:female&#125;;</span><br><span class="line">Employee e3&#123; e1 &#125;;  <span class="comment">//cp ctor 深拷贝</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><strong>数据域是一个指针，只拷指针的地址，而非指针指向的内容</strong></p>
<ul>
<li>创建新对象时，调用类的隐式&#x2F;默认构造函数</li>
<li>为已有对象赋值时，使用默认赋值运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e1&#123;<span class="string">&quot;Jack&quot;</span>, <span class="built_in">Date</span>(<span class="number">1999</span>, <span class="number">5</span>, <span class="number">3</span>),  Gender::male&#125;;</span><br><span class="line">Employee e2&#123;<span class="string">&quot;Anna&quot;</span>, <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">11</span>, <span class="number">8</span>), Gender:female&#125;;</span><br><span class="line">Employee e3&#123; e1 &#125;;  <span class="comment">//cp ctor，执行一对一成员拷贝</span></span><br></pre></td></tr></table></figure>

<p>上面的代码执行之后，e3.birthday指针指向了 e1.birthday所指向的那个Date对象</p>
<hr>
<h2 id="天方夜谭："><a href="#天方夜谭：" class="headerlink" title="天方夜谭："></a>天方夜谭：</h2><p><strong>话说你与你的好基友&#x2F;蜜友外出探险:</strong></p>
<ul>
<li><p>你的好基友&#x2F;蜜友拣了一神灯。Ta擦擦神灯，一个魔鬼从神灯中冒出来可以实现Ta的两个愿望。Ta说：1. 我要一山洞的财宝；2. 我要打开山洞的钥匙。</p>
</li>
<li><p>你也拣了一个神灯，擦擦神灯，一个魔鬼从神灯中冒出来可以实现你的两个愿望。你说：<strong>浅拷贝！</strong> 然后魔鬼给了你一把钥匙，能打开你好基友的山洞。。。你还剩下一个愿望。。。但是。。。最后你和你的好基友&#x2F;蜜友因为争抢财宝而同归于尽</p>
</li>
<li><p>你也拣了一个神灯，擦擦神灯，一个魔鬼从神灯中冒出来可以实现你的两个愿望。你说：<strong>深拷贝****！</strong> 然后魔鬼给了你另外一个山洞的财宝，给了你打开这个山洞的钥匙。。。。。。。。最后你和好基友&#x2F;蜜友幸福滴生活在一起</p>
</li>
</ul>
<hr>
<h1 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h1><p>相当于一个长度可变的数组，vector对象容量可自动增大</p>
<p>要指明数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; iV &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// Store numbers 1, ..., 10 to the vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    iV.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Iterator variables should be called <em>i, j, k</em> etc.(迭代变量名应该用 <em>i, j, k</em> 等)</p>
<p>此外，变量名 j, k应只被用于嵌套循环</p>
<hr>
<h1 id="C-14-字符串字面量"><a href="#C-14-字符串字面量" class="headerlink" title="C++14: 字符串字面量"></a>C++14: 字符串字面量</h1><h2 id="C-11“原始-生”字符串字面量"><a href="#C-11“原始-生”字符串字面量" class="headerlink" title="C++11“原始&#x2F;生”字符串字面量"></a>C++11“原始&#x2F;生”字符串字面量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s1 = <span class="string">R&quot;(Hello</span></span><br><span class="line"><span class="string">World)&quot;</span>;</span><br><span class="line"><span class="comment">// s1效果与下面的s2和s3相同</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s2 = <span class="string">&quot;Hello\nWorld&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s3 = <span class="string">R&quot;NoUse(Hello </span></span><br><span class="line"><span class="string">World)NoUse&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; s3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从例子中看出，“Raw String literals”在程序中写成什么样子，输出之后就是什么样子。我们不需要为“Raw String literals”中的换行、双引号等特殊字符进行转义</p>
<h2 id="C-14的字符串字面量"><a href="#C-14的字符串字面量" class="headerlink" title="C++14的字符串字面量"></a>C++14的字符串字面量</h2><p>C++14将运算符 <em>“”s</em> 进行了重载，赋予了它新的含义，使得用这种运算符括起来的字符串字面量，自动变成了一个 std::string 类型的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> hello = <span class="string">&quot;Hello!&quot;</span>s;              <span class="comment">// hello is of std::string type</span></span><br><span class="line"><span class="keyword">auto</span> hello = std::string&#123;<span class="string">&quot;Hello!&quot;</span>&#125;;  <span class="comment">// equals to the above</span></span><br><span class="line"><span class="keyword">auto</span> hello = <span class="string">&quot;Hello!&quot;</span>;               <span class="comment">// hello is of const char* type</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">  std::string s1 = <span class="string">&quot;abc\0\0def&quot;</span>;  </span><br><span class="line">  std::string s2 = <span class="string">&quot;abc\0\0def&quot;</span>s; </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s1: 3 “abc”</p>
<p>s2: 8 “abc^@^@def”</p>
<h1 id="编码规范进阶"><a href="#编码规范进阶" class="headerlink" title="编码规范进阶"></a>编码规范进阶</h1><p>Any violation to the guide is allowed if it enhances readability.</p>
<ul>
<li>只要能增强可读性，你在编码时可以不遵守这些编程风格指南</li>
</ul>
<p>The rules can be violated if there are strong personal objections against them.</p>
<ul>
<li>如果你有很好的个人理由的话，可以不遵守这些规范</li>
</ul>
<hr>
<p> Variables should be initialized where they are declared.</p>
<ul>
<li>变量应在其声明处初始化</li>
</ul>
<hr>
<ul>
<li>Conventional operators should be surrounded by a space character. (运算符前后应有空格)</li>
<li>C++ reserved words should be followed by a white space.(C++保留字后边应有空格)</li>
<li>Commas should be followed by a white space. (逗号后面跟空格)</li>
<li>Colons should be surrounded by white space.(冒号前后有空格)</li>
<li>Semicolons in for statments should be followed by a space character.(for语句的分号后有空格)</li>
</ul>
<hr>
<p>文件扩展名：头文件用.h，源文件用 .cpp (c++, cc也可)</p>
<p>类应该在头文件中声明并在源文件中定义，俩文件名字应该与类名相同</p>
<p>类成员变量不可被声明为public</p>
<h1 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h1><h2 id="用于数组"><a href="#用于数组" class="headerlink" title="用于数组"></a>用于数组</h2><p>结构化绑定声明是一个声明语句，意味着声明了一些标识符并对标识符做了初始化)在C++17中引入</p>
<p>将指定的一些名字绑定到初始化器的子对象或者元素上</p>
<ol>
<li><p>cv-auto &amp;&#x2F;&amp;&amp;(可选) [标识符列表] &#x3D; 表达式;</p>
</li>
<li><p>cv-auto &amp;&#x2F;&amp;&amp;(可选) [标识符列表] { 表达式 };</p>
</li>
<li><p>cv-auto &amp;&#x2F;&amp;&amp;(可选) [标识符列表] ( 表达式 );</p>
</li>
<li><p>cv-auto: 可能由const&#x2F;volatile修饰的auto关键字</p>
</li>
<li><p>&amp;&#x2F;&amp;&amp; 左值引用或者右值引用</p>
</li>
<li><p>标识符列表：逗号分隔的标识符</p>
</li>
</ol>
<hr>
<h2 id="用于对象数据成员"><a href="#用于对象数据成员" class="headerlink" title="用于对象数据成员"></a>用于对象数据成员</h2><p>若初始化表达式为类&#x2F;结构体类型，则标识符列表中的名字绑定到类&#x2F;结构体的非静态数据成员上</p>
<ol>
<li><p>数据成员必须为公有成员</p>
</li>
<li><p>标识符数量必须等于数据成员的数量</p>
</li>
<li><p>标识符类型与数据成员类型一致</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;  <span class="comment">// 可以改用 struct C，然后去掉下面的public属性说明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i &#123; <span class="number">420</span> &#125;; <span class="comment">// 就地初始化</span></span><br><span class="line">  <span class="type">char</span> ca[ <span class="number">3</span> ] &#123; <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;!&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  <span class="keyword">auto</span> [a1, a2] &#123;c&#125;; <span class="comment">// a1是int类型，a2是char[]类型</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;c.i:&quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&quot; c.ca:&quot;</span> &lt;&lt; b2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*auto后跟&amp;，则标识符是数据成员的引用</span></span><br><span class="line"><span class="comment">auto前可放置const，表明标识符是只读的*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c; <span class="comment">// c.i: 420;  c.ca: &#x27;O&#x27;,&#x27;K&#x27;,&#x27;!&#x27;</span></span><br><span class="line">  <span class="keyword">auto</span> [a1, a2] &#123;c&#125;; <span class="comment">// a1是c.i的拷贝，a2是char[]类型</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; [b1, b2] &#123;c&#125;; <span class="comment">// b1是int&amp;类型，是c.i的引用，</span></span><br><span class="line">                      <span class="comment">// b2是char(&amp;)[3]类型(数组的引用)，是c.ca的引用</span></span><br><span class="line">  a1 = <span class="number">100</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;c.i:&quot;</span> &lt;&lt; c.i &lt;&lt; std::endl; <span class="comment">// 输出420，改a1不影响c.i</span></span><br><span class="line">  b1 = <span class="number">200</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;c.i:&quot;</span> &lt;&lt; c.i &lt;&lt; std::endl; <span class="comment">// 输出200，通过b1修改了c.i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><table>
<thead>
<tr>
<th><strong>继承链上的类的对应叫法</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>基类 &#x2F; Base Class</td>
<td>派生类 &#x2F; Derived Class</td>
</tr>
<tr>
<td>父类   &#x2F; Parent Class</td>
<td>子类 &#x2F; Child Class</td>
</tr>
<tr>
<td>超类 &#x2F; SuperClass</td>
<td>子类 &#x2F; SubClass</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="center">继承 vs 泛化</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承&#x2F;Inherit</td>
<td align="center">子继承父</td>
</tr>
<tr>
<td align="center">泛化&#x2F;Generalize</td>
<td align="center">父泛化子</td>
</tr>
</tbody></table>
<hr>
<p>C++11引入<em><strong>final</strong></em>特殊标识符，可以使得类不能被继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>编译后的输出是 (Visual Studio)</p>
<p>error C3246: “D”: 无法从“B”继承，因为它已被声明为“final”这是程序输出</p>
<hr>
<p>继承的优点： 　　　　</p>
<ul>
<li><p>提高了代码的复用性 　　　　</p>
</li>
<li><p>提高了维护性 　　　　</p>
</li>
<li><p>让类与类之间产生关系 　　　　</p>
</li>
<li><p>多态的前提就是继承</p>
</li>
</ul>
<p>继承的缺点： 　　　　</p>
<ul>
<li><p>增强了类之间的耦合 　　　　</p>
</li>
<li><p>软件开发的原则是高内聚，低耦合</p>
</li>
</ul>
<h1 id="C-11：继承中的构造函数"><a href="#C-11：继承中的构造函数" class="headerlink" title="C++11：继承中的构造函数"></a>C++11：继承中的构造函数</h1><p><strong>C++11:派生类不继承的特殊函数</strong></p>
<ul>
<li>析构函数</li>
<li>友元函数</li>
</ul>
<hr>
<p>调用继承的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> d, <span class="type">int</span> i) &#123;&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A &#123;  <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A; <span class="comment">// 继承基类所有构造函数</span></span><br><span class="line">    <span class="type">int</span> d&#123;<span class="number">0</span>&#125;;   <span class="comment">// 就地初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调A(int i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>若派生类成员也需要初始化，则可以在派生类构造函数中调用基类构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i) &#123; cout &lt;&lt; <span class="string">&quot;A(int i)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">double</span> d , <span class="type">int</span> i) &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A &#123;  <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> A::A; <span class="comment">// 继承基类ctor，除了A(int i)</span></span><br><span class="line">  <span class="type">int</span> d&#123; <span class="number">0</span> &#125;; <span class="comment">// 就地初始化</span></span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> i) : A&#123; i &#125; , d&#123; i &#125; &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;B(int i)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调用 B(int i)</span></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>继承中的默认构造函数</strong></p>
<p>若基类ctor未被显式调用，基类的默认构造函数就会被调用</p>
<p><code>Circle()&#123;&#125;</code>&#x3D;<code>Circle():Shape&#123;&#125;&#123;&#125;</code></p>
<p><code>Circle(double r)&#123;&#125;</code>&#x3D;<code>Circle():Shape&#123;&#125;&#123;&#125;</code></p>
<hr>
<h1 id="构造链和析构链"><a href="#构造链和析构链" class="headerlink" title="构造链和析构链"></a>构造链和析构链</h1><h2 id="构造函数链"><a href="#构造函数链" class="headerlink" title="构造函数链"></a>构造函数链</h2><p>构造类实例会沿着继承链调用所有的基类ctor</p>
<p>父先子后</p>
<h2 id="析构函数链"><a href="#析构函数链" class="headerlink" title="析构函数链"></a>析构函数链</h2><p>子先父后</p>
<h1 id="继承中的名字隐藏"><a href="#继承中的名字隐藏" class="headerlink" title="继承中的名字隐藏"></a>继承中的名字隐藏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器报错*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> P &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  c.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部作用域的名字隐藏外部作用域的(同名)名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*using 声明语句可以将基类成员引入到派生类定义中*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> P &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> P::f; <span class="comment">//此处不带小括号</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  c.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重定义函数"><a href="#重定义函数" class="headerlink" title="重定义函数"></a>重定义函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Shape::toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::string_literals;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Shape color &quot;</span>s + color</span><br><span class="line">    + ((filled) ? <span class="string">&quot; filled&quot;</span>s : <span class="string">&quot; not filled&quot;</span>s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Circle::toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Circle color &quot;</span> + color +</span><br><span class="line">    <span class="string">&quot; filled &quot;</span> + ((filled) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Rectangle::toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;This is a rectangle object&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基类和派生类中分别定义</p>
<h1 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h1><p><strong>广义的多态：</strong>不同类型的实体&#x2F;对象对于同一消息有不同的响应，就是OOP中的<em>多态性</em></p>
<p>多态性有两种表现的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重载多态：*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">( )</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子类型多态：不同的对象调用同名重定义函数，表现出不同的行为*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>           &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">8</span>;&#125; &#125;;</span><br><span class="line">A  a; B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">a.<span class="built_in">f</span>()   <span class="comment">// call A::f()</span></span><br><span class="line">b.<span class="built_in">f</span>()   <span class="comment">// call B::f()</span></span><br><span class="line">p-&gt;<span class="built_in">f</span>(); <span class="comment">// call B::f()</span></span><br></pre></td></tr></table></figure>

<p><strong>联编(Binding)</strong>: 确定具有多态性的语句调用哪个函数的过程</p>
<p><strong>静态联编(Static Binding)</strong>:在程序编译时(Compile-time)确定调用哪个函数</p>
<p>例：函数重载</p>
<p><strong>动态联编(Dynamic Binding)</strong>:在程序运行时(Run-time)，才能够确定调用哪个函数</p>
<p>用动态联编实现的多态，也称为运行时多态(Run-time Polymorphism)</p>
<hr>
<h2 id="实现运行时多态"><a href="#实现运行时多态" class="headerlink" title="实现运行时多态"></a>实现运行时多态</h2><p><strong>HOW</strong></p>
<p>实现运行时多态有两个要素：</p>
<ul>
<li>virtual function (虚函数)</li>
<li><em>Override</em> (覆写) : <em>redefining</em> a virtual function in a derived class. (在派生类中重定义一个虚函数)</li>
</ul>
<p><strong>虚函数的传递性</strong>：基类定义了虚同名函数，那么派生类中的同名函数自动变为虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>调用哪个同名虚函数</strong></p>
<ul>
<li>不由指针类型决定</li>
<li>而由指针所指的【实际对象】的类型决定</li>
<li>运行时，检查指针所指对象类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*基类中将同名函数声明为virtual*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(A* p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*用对象指针或对象引用*/</span></span><br><span class="line">    cont &lt;&lt; p-&gt;<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a&#123;&#125;; B b&#123;&#125;; C c&#123;&#125;;</span><br><span class="line">    <span class="built_in">print</span>( &amp;a );	<span class="comment">//call A::toString()</span></span><br><span class="line">    <span class="built_in">print</span>( &amp;b );	<span class="comment">//call B::toString()</span></span><br><span class="line">    <span class="built_in">print</span>( &amp;c );	<span class="comment">//call C::toString()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>类中保存着一个Virtual function table (虚函数表)</p>
<p>Run-time binding (运行时联编&#x2F;动态联编)</p>
<p><strong>More overhead</strong> in run-time than non-virtual function (比非虚函数开销大)</p>
<h1 id="C-11：使用override和final"><a href="#C-11：使用override和final" class="headerlink" title="C++11：使用override和final"></a>C++11：使用override和final</h1><h2 id="override显式声明覆写"><a href="#override显式声明覆写" class="headerlink" title="override显式声明覆写"></a>override显式声明覆写</h2><p>C++11引入<em>override</em>标识符，指定一个虚函数覆写另一个虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 错误： B::foo 不覆写 A::foo</span></span><br><span class="line">  &#125;                           <span class="comment">// （签名不匹配）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;   <span class="comment">// OK ： B::foo 覆写 A::foo</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125; <span class="comment">// 错误： A::bar 非虚</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="comment">// 错误： override只能放到类内使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>override的价值在于：避免程序员在覆写时错命名或无虚函数导致隐藏bug</p>
<hr>
<h2 id="final-显式声明禁止覆写"><a href="#final-显式声明禁止覆写" class="headerlink" title="final 显式声明禁止覆写"></a>final 显式声明禁止覆写</h2><p>C++11引入<em>final</em>特殊标识符，指定派生类不能覆写虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// A::foo 被覆写且是最终覆写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// 错误：非虚函数不能被覆写或是 final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// struct B 为 final，不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 错误： foo 不能被覆写，因为它在 A 中是 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct可与class互换；差别在于struct的默认访问属性是public</p>
<h1 id="访问控制-可见性控制"><a href="#访问控制-可见性控制" class="headerlink" title="访问控制 (可见性控制)"></a>访问控制 (可见性控制)</h1><h2 id="the-private-and-public-keywords"><a href="#the-private-and-public-keywords" class="headerlink" title="the private and public keywords"></a>the private and public keywords</h2><ul>
<li><p>To specify whether data fields and functions can be accessed from the outside of the class. (说明数据及函数是否可以从类外面访问)</p>
</li>
<li><p>Private members can only be accessed from the inside of the class (私有成员只能在类内的函数访问)</p>
</li>
<li><p>Public members can be accessed from any other classes. (公有成员可被任何其他类访问)</p>
</li>
</ul>
<p>A <strong>protected</strong> data field or a protected function in a base class can be accessed by name in its derived classes. (保护属性的数据或函数可被派生类成员访问)</p>
<h2 id="访问属性示例"><a href="#访问属性示例" class="headerlink" title="访问属性示例"></a>访问属性示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:       <span class="comment">// 访问属性</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;        <span class="comment">// 此public为派生方式</span></span><br><span class="line"><span class="keyword">public</span>:       <span class="comment">// 访问属性</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// OK, can access i</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl; <span class="comment">// OK, can access j</span></span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl; <span class="comment">// Error! cannot access k</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  cout &lt;&lt; a.i &lt;&lt; endl; <span class="comment">// OK, can access a.i</span></span><br><span class="line">  cout &lt;&lt; a.j &lt;&lt; endl; <span class="comment">// Error, cannot access a.j</span></span><br><span class="line">  cout &lt;&lt; a.k &lt;&lt; endl; <span class="comment">// Error, cannot access a.k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*公有继承的派生类定义形式*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>：<span class="keyword">public</span> Base&#123;</span><br><span class="line">    派生类新成员定义;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基类成员  在派生类中的访问属性不变</p>
</li>
<li><p>派生类的成员函数  可以访问基类的公有成员和保护成员，不能访问基类的私有成员</p>
</li>
<li><p>派生类以外的其它函数  可以通过派生类的对象，访问从基类继承的公有成员, 但不能访问从基类继承的保护成员和私有成员</p>
</li>
</ul>
<h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*私有继承的派生类定义形式*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>：<span class="keyword">private</span> Base&#123;</span><br><span class="line">    派生类新成员定义;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基类成员  在派生类中都变成 private</p>
</li>
<li><p>派生类的成员函数  可以访问基类的公有成员和保护成员，不能访问基类的私有成员</p>
</li>
<li><p>派生类以外的其它函数  不能通过派生类的对象，访问从基类继承的任何成员</p>
</li>
</ul>
<h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*私有继承的派生类定义形：*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>：<span class="keyword">protected</span> Base&#123;</span><br><span class="line">     派生类新成员定义;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基类成员 公有成员和保护成员变成protected，私有成员不变</p>
</li>
<li><p>派生类的成员函数  可以访问基类的公有成员和保护成员，不能访问基类的私有成员</p>
</li>
<li><p>派生类以外的其它函数  不能通过派生类的对象，访问从基类继承的任何成员</p>
</li>
</ul>
<h1 id="抽象类与纯虚函数"><a href="#抽象类与纯虚函数" class="headerlink" title="抽象类与纯虚函数"></a>抽象类与纯虚函数</h1><h2 id="抽象类-类太抽象以至于无法实例化就叫做抽象类"><a href="#抽象类-类太抽象以至于无法实例化就叫做抽象类" class="headerlink" title="抽象类:类太抽象以至于无法实例化就叫做抽象类"></a><strong>抽象类</strong>:类太抽象以至于无法实例化就叫做抽象类</h2><p>抽象函数也叫纯虚函数</p>
<p><strong>成员函数应出现在哪个继承层次</strong></p>
<p>问题：Shape类层次中，getArea()函数放在哪个层次</p>
<p>选择1：放哪儿都行：Shape中或子类中定义getArea()</p>
<p>选择2：强制要求Shape子类必须实现getArea()</p>
<hr>
<p><strong>抽象函数(abstract functions)要求子类实现它</strong></p>
<p><strong>virtual</strong> double getArea() <strong>&#x3D; 0</strong>; &#x2F;&#x2F; 在Shape类中</p>
<p>Circle子类必须实现getArea()纯虚函数才能实例化</p>
<hr>
<p> <strong>包含抽象函数的类被称为抽象类</strong></p>
<p>抽象类不能实例化（创建对象）</p>
<h1 id="动态类型转换"><a href="#动态类型转换" class="headerlink" title="动态类型转换"></a>动态类型转换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printObject</span><span class="params">(Shape&amp; shape)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// shape是派生类对象的引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The area is &quot;</span> </span><br><span class="line">       &lt;&lt; shape.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 如果shape是Circle对象，就输出半径</span></span><br><span class="line">  <span class="comment">// 如果shape是Rectangle对象，就输出宽高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dynamic-cast-运算符"><a href="#dynamic-cast-运算符" class="headerlink" title="dynamic_cast 运算符"></a>dynamic_cast 运算符</h2><p>(1)   沿继承层级向上、向下及侧向转换到类的指针和引用</p>
<p>(2)   转指针：失败返回nullptr</p>
<p>(3)   转引用：失败抛异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*先将Shape对象用dynamic_cast转换为派生类Circle对象然后调用派生类中独有的函数*/</span></span><br><span class="line"><span class="comment">// A function for displaying a Shape object</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printObject</span><span class="params">(Shape &amp;shape)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The area is &quot;</span> </span><br><span class="line">       &lt;&lt; shape.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">  Shape *p = &amp;shape;</span><br><span class="line">  Circle *c = <span class="built_in">dynamic_cast</span>&lt;Circle*&gt;(p);</span><br><span class="line">  <span class="comment">// Circle&amp; c = dynamic_cast&lt;Circle&amp;&gt;(shape); </span></span><br><span class="line">  <span class="comment">// 引用转换失败则抛出一个异常 std::bad_cast</span></span><br><span class="line">  <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) <span class="comment">// 转换失败则指针为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The radius is &quot;</span> </span><br><span class="line">         &lt;&lt; p1-&gt;<span class="built_in">getRadius</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The diameter is &quot;</span> </span><br><span class="line">         &lt;&lt; p1-&gt;<span class="built_in">getDiameter</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Upcasting-and-Downcasting-向上-向下-转型"><a href="#Upcasting-and-Downcasting-向上-向下-转型" class="headerlink" title="Upcasting and Downcasting (向上&#x2F;向下 转型)"></a>Upcasting and Downcasting (向上&#x2F;向下 转型)</h2><p><strong>upcasting</strong>：将派生类类型指针赋值给基类类型指针</p>
<p><strong>downcasting</strong>：将基类类型指针赋值给派生类类型指针</p>
<ul>
<li><h3 id="上转可不使用dynamic-cast而隐式转换"><a href="#上转可不使用dynamic-cast而隐式转换" class="headerlink" title="上转可不使用dynamic_cast而隐式转换"></a>上转可不使用dynamic_cast而隐式转换</h3></li>
<li><p>上转隐，下转显</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape* s = <span class="literal">nullptr</span>;</span><br><span class="line">Circle *c = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">2</span>);</span><br><span class="line">s = c; <span class="comment">//OK,隐式上转</span></span><br></pre></td></tr></table></figure>

<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><ol>
<li>可将派生类对象截断，只使用继承来的信息</li>
<li>但不能将基类对象加长，无中生有变出派生类对象</li>
</ol>
<h1 id="typeid-运行时查询类型的信息"><a href="#typeid-运行时查询类型的信息" class="headerlink" title="typeid  运行时查询类型的信息"></a>typeid  运行时查询类型的信息</h1><p><strong>typeid用于获取对象所属的类的信息</strong></p>
<ul>
<li>typeid运算符返回一个type_info对象的<strong>引用</strong></li>
<li><code> typeid(AType).name()</code>返回<strong>实现定义</strong>的，含有类型名称的C风格字符串(char *)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span>  <span class="comment">//使用typeid，需要包含此头文件 </span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line">A a&#123;&#125;;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; t1 = <span class="built_in">typeid</span>(a);<span class="comment">/*auto&amp; 引用*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(A) == t1) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a has type &quot;</span> </span><br><span class="line">              &lt;&lt; t1.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出(visual studio)</p>
<p>class A</p>
<p>可能的输出(g++)</p>
<p>1A</p>
<h1 id="C-17的文件系统库简介"><a href="#C-17的文件系统库简介" class="headerlink" title="C++17的文件系统库简介"></a>C++17的文件系统库简介</h1><h2 id="About-std-filesystem"><a href="#About-std-filesystem" class="headerlink" title="About std::filesystem"></a>About std::filesystem</h2><p>C++17 std::filesystem provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories（标准库的filesystem提供在文件系统与其组件，例如路径、常规文件与目录上进行操作的方法）</p>
<h3 id="Some-terms-一些术语"><a href="#Some-terms-一些术语" class="headerlink" title="Some terms(一些术语)"></a>Some terms(一些术语)</h3><ul>
<li><p>File(文件)：持有数据的文件系统对象，能被写入或读取。文件有名称和属性，属性之一是文件类型</p>
</li>
<li><p>Path(路径)：标识文件所处位置的一系列元素，可能包含文件名</p>
</li>
</ul>
<h3 id="路径类："><a href="#路径类：" class="headerlink" title="路径类："></a>路径类：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line">fs::path p&#123; <span class="string">&quot;CheckPath.cpp&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="路径类及操作"><a href="#路径类及操作" class="headerlink" title="路径类及操作"></a>路径类及操作</h1><h2 id="path类的成员函数"><a href="#path类的成员函数" class="headerlink" title="path类的成员函数"></a>path类的成员函数</h2><table>
<thead>
<tr>
<th align="center">部分重要的成员函数</th>
<th align="center"><strong>说明</strong></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">+path(string)</td>
<td align="center">构造函数</td>
</tr>
<tr>
<td align="center">+assign(string): path&amp;</td>
<td align="center">为路径对象赋值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">连接</td>
<td align="center">+append(type p): path&amp;</td>
<td align="center">将p追加到路径后。type是string、path或const char*。等价于  &#x2F;&#x3D; 运算符；自动添加目录分隔符</td>
</tr>
<tr>
<td align="center">+concat(type p): path&amp;</td>
<td align="center">将p追加到路径后。type是string、path或const char*。等价于+&#x3D;运算符；不自动添加目录分隔符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">修改器</td>
<td align="center">+clear(): void</td>
<td align="center">清空存储的路径名</td>
</tr>
<tr>
<td align="center">+remove_filename(): path&amp;</td>
<td align="center">从给定的路径中移除文件名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+replace_filename(const path&amp;  replacement): path&amp;</td>
<td align="center">以 replacement 替换文件名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">分解</td>
<td align="center">+root_name(): path</td>
<td align="center">返回通用格式路径的根名</td>
</tr>
<tr>
<td align="center">+root_directory(): path</td>
<td align="center">返回通用格式路径的根目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+root_path(): path</td>
<td align="center">返回路径的根路径，等价于  root_name() &#x2F; root_directory()，即“路径的根名 &#x2F; 路径的根目录”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+relative_path(): path</td>
<td align="center">返回相对于 root-path 的路径</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+parent_path(): path</td>
<td align="center">返回到父目录的路径</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+filename(): path</td>
<td align="center">返回路径中包含的文件名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+stem(): path</td>
<td align="center">返回路径中包含的文件名，不包括文件的扩展名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">+extension(): path</td>
<td align="center">返回路径中包含的文件名的扩展名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">查询</td>
<td align="center">+empty(): bool</td>
<td align="center">检查路径是否为空</td>
</tr>
<tr>
<td align="center">+has_xxx(): bool</td>
<td align="center">其中“xxx”是上面“分解”类别中的函数名。这些函数检查路径是否含有相应路径元素</td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<h2 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h2><table>
<thead>
<tr>
<th align="center">** 部分重要的非成员函数**</th>
<th align="center"><strong>说明</strong></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">operator&#x2F;( const path&amp; lhs, const  path&amp; rhs )</td>
<td align="center">以偏好目录分隔符连接二个路径成分  lhs 和  rhs。比如  path p{“C:”}; p &#x3D; p &#x2F; “Users” &#x2F;  “batman”;</td>
</tr>
<tr>
<td align="center">operator &lt;&lt;, &gt;&gt; (path p)</td>
<td align="center">进行路径 p 上的流输入或输出</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">文件类型</td>
<td align="center">s_regular_file( const path&amp; p ): bool</td>
<td align="center">检查路径是否是常规文件</td>
</tr>
<tr>
<td align="center">is_directory( const path&amp; p ): bool</td>
<td align="center">检查路径是否是目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">is_empty( const path&amp; p ): bool</td>
<td align="center">检查给定路径是否指代一个空文件或目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">查询</td>
<td align="center">current_path(): pathcurrent_path( const path&amp; p ): void</td>
<td align="center">返回当前工作目录的绝对路径（类似linux指令 pwd）更改当前路径为p （类似linux指令 cd）</td>
</tr>
<tr>
<td align="center">file_size( const path&amp; p ): uintmax_t</td>
<td align="center">对于常规文件 p ，返回其大小；尝试确定目录(以及其他非常规文件)的大小的结果是由编译器决定的</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">space(const path&amp; p): space_info</td>
<td align="center">返回路径名 p 定位于其上的文件系统信息。space_info中有三个成员：capacity ——文件系统的总大小(字节)，free ——文件系统的空闲空间(字节)，available ——普通进程可用的空闲空间（小于或等于  free ）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">status(const path&amp; p): file_status</td>
<td align="center">返回 p 所标识的文件系统对象的类型与属性。返回的file_status是一个类，其中包含文件的类型(type)和权限(permissions)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">修改</td>
<td align="center">remove(const path&amp; p): boolremove_all(const path&amp; p): uintmax_t</td>
<td align="center">删除路径 p 所标识的文件或空目录递归删除 p 的内容（若它是目录）及其子目录的内容，然后删除  p 自身，返回被删文件及目录数量</td>
</tr>
<tr>
<td align="center">rename(const path&amp; old_p,      const path&amp; new_p): void</td>
<td align="center">移动或重命名 old_p 所标识的文件系统对象到  new_p(类似linux指令mv)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">copy( const path&amp; from, const  path&amp; to ): void</td>
<td align="center">复制文件与目录。另外一个函数  bool copy_file(from, to) 拷贝单个文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">create_directory( const path&amp; p ):  boolcreate_directories( const path&amp; p ):  bool</td>
<td align="center">创建目录 p （父目录必须已经存在）,若 p 已经存在，则函数无操作创建目录 p （父目录不一定存在）,若 p 已经存在，则函数无操作</td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="Introduction-to-the-Input-and-Output-Classes"><a href="#Introduction-to-the-Input-and-Output-Classes" class="headerlink" title="Introduction to the Input and Output Classes"></a>Introduction to the Input and Output Classes</h1><h2 id="between-C-and-C-文件操作对比"><a href="#between-C-and-C-文件操作对比" class="headerlink" title="between C and C++ (文件操作对比)"></a>between C and C++ (文件操作对比)</h2><table>
<thead>
<tr>
<th></th>
<th>C++</th>
<th>C</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Header File (**<strong>头文件)</strong></td>
<td><strong>file input</strong></td>
<td>ifstream <em>(i: input; f:file)</em></td>
<td>stdio.h</td>
</tr>
<tr>
<td><strong>file output</strong></td>
<td>ofstream <em>(o: ouput; f:file)</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>file input &amp; output</strong></td>
<td>fstream</td>
<td></td>
<td></td>
</tr>
<tr>
<td>**Read&#x2F;****Write (**<strong>读写操作)</strong></td>
<td>**read from file   (**<strong>读文件)</strong></td>
<td>&gt;&gt;;get(); get(char); get(char*);getline();read(char*,streamsize);</td>
<td>fscanf();fgets(char*, size_t , FILE*);fread(void *<em>ptr</em>, <em>size</em>, <em>nitems</em>,  FILE *<em>stream</em>);</td>
</tr>
<tr>
<td>**write to file   (**<strong>写文件)</strong></td>
<td>&lt;&lt;;put(char), put(int);write (const char*, streamsize);flush()</td>
<td>fprintf();fwrite(const void *<em>ptr</em>, <em>size</em>,  <em>nitems</em>, FILE <em><em>stream</em>);fputs(const char</em>, FILE *);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>**Status test   (**<strong>状态测试)</strong></td>
<td>eof(); bad(); good(); fail()</td>
<td>feof(); ferror();</td>
</tr>
</tbody></table>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是一个数据序列</p>
<hr>
<p><strong>C++的流类主要有五类：</strong></p>
<ol>
<li><p>流基类（ios_base和ios）</p>
</li>
<li><p>标准输入输出流类（istream&#x2F;ostream&#x2F;iostream）</p>
</li>
<li><p>字符串流类（istringstream&#x2F;ostringstream）</p>
</li>
<li><p>文件流类（ifstream&#x2F;ofstream&#x2F;fstream）</p>
</li>
<li><p>缓冲区类（streambuf&#x2F;stringbuf&#x2F;filebuf）</p>
</li>
</ol>
<p>标准输入输出流对象 cin 和 cout 分别是类 istream 和 ostream 的实例</p>
<p>字符串流：将各种不同的数据格式化输出到一个字符串中，可以使用I&#x2F;O操纵器控制格式；反之也可以从字符串中读入各种不同的数据</p>
<h2 id="带缓冲的输入输出"><a href="#带缓冲的输入输出" class="headerlink" title="带缓冲的输入输出"></a>带缓冲的输入输出</h2><p>C++的I&#x2F;O流是有内部缓冲区的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        c = cin.<span class="built_in">get</span>(); </span><br><span class="line">        cout &lt;&lt; ++i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; </span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c &#x3D; cin.get(<strong>void</strong>)每次读取一个字符并把由Enter键生成的换行符留在输入队列中</p>
<h1 id="向文件写入数据"><a href="#向文件写入数据" class="headerlink" title="向文件写入数据"></a>向文件写入数据</h1><p>ofstrem可向文本文件中写数据</p>
<p><img src="/img%5C25E9455E1328577B96EF36ED9E09C3E7.jpg" alt="25E9455E1328577B96EF36ED9E09C3E7"></p>
<p>文件已存在,内容被直接清除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output &lt;&lt; <span class="string">&quot;LiHua&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">90.5</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="从文件读数据"><a href="#从文件读数据" class="headerlink" title="从文件读数据"></a>从文件读数据</h1><p>ifstrem可从文本文件中读数据</p>
<p>检测文件是否成功打开</p>
<p><img src="/img%5CA08D7DA2B4D44442E89724B4256254CB.jpg" alt="A08D7DA2B4D44442E89724B4256254CB"></p>
<p>若想正确读出数据，必须确切了解数据的存储格式</p>
<hr>
<p>检测文件是否正确打开的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*open()之后马上调用fail()函数*/</span></span><br><span class="line"><span class="comment">/*fail()返回true, 文件未打开*/</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(<span class="string">&quot;scores.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (output.<span class="built_in">fail</span>())  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">R&quot;(Can&#x27;t open file &quot;scores.txt&quot;!)&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>检测是否已到文件末尾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用eof()函数检查是否是文件末尾*/</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;scores.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (in.<span class="built_in">eof</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(in.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="“设置域宽”控制符"><a href="#“设置域宽”控制符" class="headerlink" title="“设置域宽”控制符"></a>“设置域宽”控制符</h2><p>要包含头文件 <iomanip></p>
<p>setw(n) 设置域宽，即数据所占的总字符数</p>
<p>setw()的默认为setw(0)，按实际输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&#x27;a&#x27;</span> </span><br><span class="line">            &lt;&lt;  std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*_ _a*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*setw()控制符只对其后输出的第一个数据有效，其他控制符则对其后的所有输入输出产生影响*/</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&#x27;b&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">/*_ _ _ _ab*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果输出的数值占用的宽度超过setw(int n)设置的宽度，则按实际宽度输出*/</span></span><br><span class="line"><span class="type">float</span> f=<span class="number">0.12345</span>;</span><br><span class="line"> std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; f </span><br><span class="line">           &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">/*0.12345*/</span></span><br></pre></td></tr></table></figure>

<h2 id="“设置浮点精度”控制符"><a href="#“设置浮点精度”控制符" class="headerlink" title="“设置浮点精度”控制符"></a>“设置浮点精度”控制符</h2><p>setprecision(int n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">float</span> f = <span class="number">17</span> / <span class="number">7.0</span>;</span><br><span class="line">  cout &lt;&lt;                    f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.42857</span></span><br><span class="line"><span class="comment">2.42857</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2.4</span></span><br><span class="line"><span class="comment">2.43</span></span><br><span class="line"><span class="comment">2.42857</span></span><br><span class="line"><span class="comment">2.4285715</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="“设置填充字符”控制符"><a href="#“设置填充字符”控制符" class="headerlink" title="“设置填充字符”控制符"></a>“设置填充字符”控制符</h2><p>setfill(c)</p>
<p>设置填充字符，即“&lt;&lt;”符号后面的数据长度小于域宽时，使用什么字符进行填充</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">           &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;a&#x27;</span> </span><br><span class="line">           &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">/*1111a*/</span></span><br></pre></td></tr></table></figure>

<h2 id="在文件操作中格式化输入-输出"><a href="#在文件操作中格式化输入-输出" class="headerlink" title="在文件操作中格式化输入&#x2F;输出"></a>在文件操作中格式化输入&#x2F;输出</h2><table>
<thead>
<tr>
<th><strong>控制符</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>setw(width)</td>
<td>设置输出字段的宽度(仅对其后第一个输出有效)</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>设置浮点数的输&#x2F;入出精度(总有效数字个数等于n)</td>
</tr>
<tr>
<td>fixed</td>
<td>将浮点数以定点数形式输入&#x2F;出(小数点后有效数字个数等于setprecision指定的n)</td>
</tr>
<tr>
<td>showpoint</td>
<td>将浮点数以带小数点和结尾0的形式输入&#x2F;出，即便该浮点数没有小数部分</td>
</tr>
<tr>
<td>left</td>
<td>输出内容左对齐</td>
</tr>
<tr>
<td>right</td>
<td>输出内容右对齐</td>
</tr>
<tr>
<td>hexfloat&#x2F;defaultfloat</td>
<td>C++11新增；前者以定点科学记数法的形式输出十六进制浮点数，后者还原默认浮点格式</td>
</tr>
<tr>
<td>get_money(money)put_money(money)</td>
<td>C++11新增；从流中读取货币值，或者将货币值输出到流。支持不同语言和地区的货币格式<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/io/manip/get_moneyhttps://en.cppreference.com/w/cpp/io/manip/put_money">https://en.cppreference.com/w/cpp/io/manip/get_moneyhttps://en.cppreference.com/w/cpp/io/manip/put_money</a></td>
</tr>
<tr>
<td>get_time(tm,  format)put_time(tm,format)</td>
<td>C++11新增；从流中读取日期时间值，或者将日期时间值输出到流。<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/io/manip/get_timehttps://en.cppreference.com/w/cpp/io/manip/put_time">https://en.cppreference.com/w/cpp/io/manip/get_timehttps://en.cppreference.com/w/cpp/io/manip/put_time</a></td>
</tr>
</tbody></table>
<h1 id="用于输入-输出流的函数"><a href="#用于输入-输出流的函数" class="headerlink" title="用于输入&#x2F;输出流的函数"></a>用于输入&#x2F;输出流的函数</h1><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p><code>&gt;&gt;</code>运算符用空格分隔数据</p>
<p>对于文件内容：</p>
<p>Li Lei#Han Meimei#Adam</p>
<p>如下代码只能读入“Li”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;name.txt&quot;</span>)</span></span>;</span><br><span class="line">std::string name;</span><br><span class="line">input &gt;&gt; name;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Read in &quot;Li Lei&quot; with member function getline(char* buf, int size, char delimiter)*/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> SIZE&#123; <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">char</span> , SIZE&gt; name&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!input.<span class="built_in">eof</span>()) &#123;<span class="comment">// not end of file</span></span><br><span class="line"></span><br><span class="line">  input.<span class="built_in">getline</span>(&amp;name[ <span class="number">0</span> ] , SIZE , <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &amp;name[ <span class="number">0</span> ] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Read in &quot;Li Lei&quot; with non-member function std::getline(istream&amp; is, string&amp; str, char delimiter)*/</span></span><br><span class="line">std::string name2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!input.<span class="built_in">eof</span>()) &#123;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">getline</span>(input, name2, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-and-put"><a href="#get-and-put" class="headerlink" title="get() and put()"></a>get() and put()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重载函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">istream::get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span> <span class="params">(<span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h2><p>将输出流缓存中的数据写入目标文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">flush</span>(); <span class="comment">// 其它输出流对象也可以调用 flush()</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::flush; <span class="comment">// 与endl类似作为manipulator的调用方式</span></span><br></pre></td></tr></table></figure>

<h1 id="二进制文件输入与输出"><a href="#二进制文件输入与输出" class="headerlink" title="二进制文件输入与输出"></a>二进制文件输入与输出</h1><h2 id="文件的打开模式"><a href="#文件的打开模式" class="headerlink" title="文件的打开模式"></a>文件的打开模式</h2><p>fstream与文件打开模式</p>
<p><em>ofstream</em> : 写数据;   <em>ifstream</em> : 读数据</p>
<p><em>fstream</em> &#x3D; <em>ofstream</em>    +    <em>ifstream</em></p>
<p><strong>创建fstream对象时，应指定文件打开模式</strong></p>
<table>
<thead>
<tr>
<th><strong>Mode(<strong><strong>模式</strong></strong>)</strong></th>
<th><strong>Description(<strong><strong>描述</strong></strong>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>打开文件读数据</td>
</tr>
<tr>
<td>ios::out</td>
<td>打开文件写数据</td>
</tr>
<tr>
<td>ios::app</td>
<td>把输出追加到文件末尾。app &#x3D; append</td>
</tr>
<tr>
<td>ios::ate</td>
<td>打开文件，把文件光标移到末尾。ate &#x3D; at end</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>若文件存在则舍弃其内容。这是ios::out的默认行为。trunc &#x3D; truncate</td>
</tr>
<tr>
<td>ios::binary</td>
<td>打开文件以二进制模式读写</td>
</tr>
</tbody></table>
<h2 id="模式组合"><a href="#模式组合" class="headerlink" title="模式组合"></a>模式组合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Open Mode的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::ios_base::openmode 被ios继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="comment">/*implementation defined*/</span> openmode;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> openmode app = <span class="comment">/*implementation defined*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//几种模式可以组合在一起</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> the | <span class="built_in">operator</span> (bitwise inclusive OR) (用“位或”运算符)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.<span class="built_in">open</span>(<span class="string">&quot;name.txt&quot;</span>, ios::out | ios::app);</span><br></pre></td></tr></table></figure>

<h2 id="二进制输入输出简介"><a href="#二进制输入输出简介" class="headerlink" title="二进制输入输出简介"></a>二进制输入输出简介</h2><p><strong>文本文件与二进制文件</strong></p>
<ul>
<li><p>都按二进制格式存储比特序列</p>
</li>
<li><p>text file:解释为一系列字符</p>
</li>
<li><p>binary file:解释为一系列比特</p>
</li>
</ul>
<p>*<em>Windows文件的换行(CRLF) vs <em>nix文件的换行(LF)</em></em></p>
<p>在Windows上，’\n’输出到文件中会自动编码为’\r’ ‘\n’ 两个字符</p>
<p>在*nix上，’\n’ 字符输出到文件中不变</p>
<hr>
<p>文本模式的读写是建立在二进制模式读写的基础上的，只不过是将二进制信息进行了字符编解码</p>
<p><strong>二进制读写无需信息转换</strong></p>
<table>
<thead>
<tr>
<th>** Text  I&#x2F;O (<strong><strong>文本模式</strong></strong>)**</th>
<th><strong>Binary  I&#x2F;O function:(<strong><strong>二进制模式</strong></strong>)</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>operator  &gt;&gt;; get(); getline();</td>
<td>read();</td>
</tr>
<tr>
<td>写</td>
<td>operator  &lt;&lt;; put();</td>
<td>write();</td>
</tr>
</tbody></table>
<h1 id="如何实现二进制读写"><a href="#如何实现二进制读写" class="headerlink" title="如何实现二进制读写"></a>如何实现二进制读写</h1><h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>ostream&amp; write( const char* s, std::streamsize count )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*可直接将字符串写入文件*/</span></span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;GreatWall.dat&quot;</span>, ios::binary|ios::trunc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;ShanHaiGuan\nJuYongGuan&quot;</span>;</span><br><span class="line"></span><br><span class="line">fs.<span class="built_in">write</span>(s, <span class="built_in">sizeof</span>(s));</span><br></pre></td></tr></table></figure>

<h2 id="如何将非字符数据写入文件"><a href="#如何将非字符数据写入文件" class="headerlink" title="如何将非字符数据写入文件"></a>如何将非字符数据写入文件</h2><ul>
<li><p>先将数据转换为字节序列，即字节流</p>
</li>
<li><p>Write the sequence of bytes to file with write() (再用write函数将字节序列写入文件</p>
</li>
</ul>
<h2 id="如何将信息转换为字节流"><a href="#如何将信息转换为字节流" class="headerlink" title="如何将信息转换为字节流"></a>如何将信息转换为字节流</h2><p><code>reinterpret_cast</code>运算符</p>
<ul>
<li><p>将一种类型的地址转为另一种类型的地址</p>
</li>
<li><p>将地址转换为数值，比如转换为整数</p>
</li>
</ul>
<p><strong>语法:  <em>reinterpret_cast</em><dataType>(address)</strong> </p>
<ul>
<li><p>address是待转换的数据的起始地址</p>
</li>
<li><p>dataType是要转至的目标类型</p>
</li>
</ul>
<p> (对于二进制I&#x2F;O来说，dataType是 char*)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> x &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] &#123;<span class="number">21</span>,<span class="number">42</span>,<span class="number">63</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::string str&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;x); <span class="comment">// variable address</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* p2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(a);  <span class="comment">// array address</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* p3 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;str); <span class="comment">// object address</span></span><br></pre></td></tr></table></figure>

<h2 id="read成员函数"><a href="#read成员函数" class="headerlink" title="read成员函数"></a>read成员函数</h2><p>prototype (函数原型)</p>
<p><strong><code>istream&amp; read ( char* s, std::streamsize count );</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">fstream <span class="title">bio</span><span class="params">(<span class="string">&quot;GreatWall.dat&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">bio.<span class="built_in">read</span>(s, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s;</span><br><span class="line"></span><br><span class="line">bio.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读其它类型数据（整数），需要使用 *reinterpret_cast*</span></span><br><span class="line"></span><br><span class="line"><span class="function">fstream <span class="title">bio</span><span class="params">(<span class="string">&quot;temp.dat&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">bio.<span class="built_in">read</span>(*<span class="keyword">reinterpret_cast</span>*&lt;<span class="type">char</span> *&gt;(&amp;value), <span class="built_in">sizeof</span>(value));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; value;</span><br></pre></td></tr></table></figure>

<h1 id="文件位置指示器"><a href="#文件位置指示器" class="headerlink" title="文件位置指示器"></a>文件位置指示器</h1><h3 id="fp"><a href="#fp" class="headerlink" title="fp"></a>fp</h3><ul>
<li><p>文件由字节序列构成</p>
</li>
<li><p>一个特殊标记指向其中一个字节</p>
</li>
</ul>
<p>读写操作都是从文件位置指示器所标记的位置开始</p>
<ul>
<li><p>打开文件，fp指向文件头</p>
</li>
<li><p>When you read or write data to the file, the file pointer moves forward to the next data item. (读写文件时，文件位置指示器会向后移动到下一个数据项</p>
</li>
</ul>
<h1 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h1><p><strong>随机访问意味着可以读写文件的任意位置</strong></p>
<ul>
<li><p>我们能知道文件定位器在什么位置</p>
</li>
<li><p>我们能在文件中移动文件定位器</p>
</li>
<li><p>Maybe we need two file positioners : one for reading, another for writing</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>·</strong></th>
<th>**For reading (**<strong>读文件时用)</strong></th>
<th>**For writing(**<strong>写文件时用)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>获知文件定位器指到哪里</td>
<td><em>tellg();</em> tell是获知，g是get表示读文件</td>
<td><em>tellp();</em> tell是获知，p是put表示写文件</td>
</tr>
<tr>
<td>移动文件定位器到指定位置</td>
<td><em>seekg();</em> seek是寻找，g是get表示读文件</td>
<td><em>seekp();</em> seek是寻找，p是put表示写文件</td>
</tr>
</tbody></table>
<hr>
<p><strong>seek的原型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_stream&amp; seekg/<span class="built_in">seekp</span>( pos_type pos );</span><br><span class="line"></span><br><span class="line">xxx_stream&amp; seekg/<span class="built_in">seekp</span>( off_type off, std::ios_base::seekdir dir);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>seekdir</strong> <strong>文件定位方向类型</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>std::ios_base::beg</td>
<td>流的开始；beg &#x3D; begin</td>
</tr>
<tr>
<td>std::ios_base::end</td>
<td>流的结尾</td>
</tr>
<tr>
<td>std::ios_base::cur</td>
<td>流位置指示器的当前位置；cur &#x3D; current</td>
</tr>
</tbody></table>
<p><strong>例子</strong></p>
<p><strong>解释</strong></p>
<p>seekg(42L);</p>
<p>将文件位置指示器移动到文件的第42字节处</p>
<p>seekg(10L, std::ios::beg);</p>
<p>将文件位置指示器移动到从文件开头算起的第10字节处</p>
<p>seekp(-20L, std::ios::end);</p>
<p>将文件位置指示器移动到从文件末尾开始，倒数第20字节处</p>
<p>seekp(-36L, std::ios::cur);</p>
<p>将文件位置指示器移动到从当前位置开始，倒数第36字节处</p>
<h1 id="运算符与函数"><a href="#运算符与函数" class="headerlink" title="运算符与函数"></a>运算符与函数</h1><h2 id="与对象一起用的运算符"><a href="#与对象一起用的运算符" class="headerlink" title="与对象一起用的运算符"></a>与对象一起用的运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*string类：使用“+”连接两个字符串*/</span></span><br><span class="line"><span class="comment">/*类中重载了+运算符*/</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1 + s2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*array 与 vector类：使用[] 访问元素*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">char</span>, 3&gt; a&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v</span><span class="params">(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>; <span class="comment">//&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] v[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*path类：使用“/”连接路径元素*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">std::filesystem::path p&#123;&#125;; </span><br><span class="line"></span><br><span class="line">p = p / <span class="string">&quot;C:&quot;</span> / <span class="string">&quot;Users&quot;</span> / <span class="string">&quot;cyd&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="运算符与函数的异同"><a href="#运算符与函数的异同" class="headerlink" title="运算符与函数的异同"></a>运算符与函数的异同</h2><p>运算符可以看做是函数，只是运算符编辑器要进一步解析，而函数可以直接调用</p>
<h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><h4 id="语法上有区别"><a href="#语法上有区别" class="headerlink" title="语法上有区别"></a>语法上有区别</h4><p>3 * 2        &#x2F;&#x2F;中缀式</p>
<p>* 3 2       &#x2F;&#x2F;前缀式</p>
<p>multiply ( 3, 2) ; &#x2F;&#x2F;前缀式</p>
<p>3  2  *        &#x2F;&#x2F;后缀式(RPN)</p>
<h4 id="不能自定义新的运算符-只能重载"><a href="#不能自定义新的运算符-只能重载" class="headerlink" title="不能自定义新的运算符 (只能重载)"></a>不能自定义新的运算符 (只能重载)</h4><p>3 ** 2    &#x2F;&#x2F; C&#x2F;C++中错误</p>
<p>pow(3, 2) &#x2F;&#x2F; 3的平方</p>
<h4 id="函数可overload-override产生任何想要的结果，但运算符作用于内置类型的行为不能修改"><a href="#函数可overload-override产生任何想要的结果，但运算符作用于内置类型的行为不能修改" class="headerlink" title="函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改"></a>函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改</h4><p>multiply (3, 2)  &#x2F;&#x2F; 可以返回1</p>
<p>3 * 2            &#x2F;&#x2F; 结果必须是6</p>
<h3 id="函数式编程语言的观念"><a href="#函数式编程语言的观念" class="headerlink" title="函数式编程语言的观念"></a>函数式编程语言的观念</h3><p>一切皆是函数</p>
<p>Haskell中可以定义新的运算符</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://fl0.top">庄生晓梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/09/26/C++/">http://example.com/2020/09/26/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/02/EEA/" title="公钥加密数学基础-欧几里得算法"><img class="cover" src="/./iimmgg/wallhaven-kw6v96.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">公钥加密数学基础-欧几里得算法</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/26/js/" title="js学习记录"><img class="cover" src="/./iimmgg/wallhaven-kw6v96.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">js学习记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/10/14/C++%E9%AB%98%E7%BA%A7%E5%AE%8F%E6%93%8D%E4%BD%9C/" title="C++高级宏操作"><img class="cover" src="/./iimmgg/sekiro.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-14</div><div class="title">C++高级宏操作</div></div></a></div><div><a href="/2021/04/03/Games101-06-Rasterization%EF%BC%88Antialising%EF%BC%89/" title="Games101-Rasterization(Antialiasing and Z-Buffer）笔记"><img class="cover" src="/./iimmgg/79399507_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-03</div><div class="title">Games101-Rasterization(Antialiasing and Z-Buffer）笔记</div></div></a></div><div><a href="/2021/11/25/Inside_C++_Obj_Model/" title="Inside The C++ Object Model简单记录"><img class="cover" src="/./iimmgg/20211125-120723.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">Inside The C++ Object Model简单记录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://thirdqq.qlogo.cn/g?b=sdk&amp;k=q5qVDcvyzxee4qiays52mibA&amp;s=640" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">庄生晓梦</div><div class="author-info__description">@Vidar-Team @Game Lover</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fl0a1e" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1324063714@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/173319694" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #24292e;"></i></a><a class="social-icon" href="https://fl0.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1.基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">1.0.2.</span> <span class="toc-text">命名空间&#x2F;名字空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.0.4.</span> <span class="toc-text">输入输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-C%E7%9A%84%E5%A2%9E%E5%BC%BA%E5%92%8CC-%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2.C的增强和C++特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">传参</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.</span> <span class="toc-text">3.空指针和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E9%80%9A%E8%BF%87%E8%BF%90%E7%AE%97%E7%AC%A6new%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">3.0.1.</span> <span class="toc-text">C++中通过运算符new申请动态内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E8%A6%81%E7%94%A8delete%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9D%A5%E9%87%8A%E6%94%BE"><span class="toc-number">3.0.2.</span> <span class="toc-text">动态内存使用完毕后，要用delete运算符来释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-delete%E5%92%8Cmalloc-free%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.3.</span> <span class="toc-text">new&#x2F;delete和malloc&#x2F;free区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-bool%EF%BC%8C%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">4.bool，列表初始化，强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bool"><span class="toc-number">4.0.1.</span> <span class="toc-text">bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.0.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.0.3.</span> <span class="toc-text">类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-c-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.</span> <span class="toc-text">5.c++自动类型推导</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">6.内存模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B8%B8%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">7.常量和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.0.1.</span> <span class="toc-text">常量和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using"><span class="toc-number">7.0.2.</span> <span class="toc-text">using</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="toc-number">7.0.3.</span> <span class="toc-text">常函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">8.对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D"><span class="toc-number">8.0.1.</span> <span class="toc-text">名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B1%BB"><span class="toc-number">8.0.2.</span> <span class="toc-text">构造类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%A3%B0%E6%98%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">8.0.3.</span> <span class="toc-text">对象拷贝和声明实现分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.0.3.1.</span> <span class="toc-text">成员拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.0.3.2.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="toc-number">8.0.3.3.</span> <span class="toc-text">结构体和类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%95%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.3.4.</span> <span class="toc-text">罕见操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.0.3.5.</span> <span class="toc-text">上机实验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB"><span class="toc-number">8.0.4.</span> <span class="toc-text">分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">8.0.4.1.</span> <span class="toc-text">名词解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C-1"><span class="toc-number">8.0.4.2.</span> <span class="toc-text">上机实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Avoiding-Multiple-Inclusion-of-Header-Files"><span class="toc-number">8.0.4.3.</span> <span class="toc-text">Avoiding Multiple Inclusion of Header Files</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%EF%BC%8C%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">对象指针，对象数组和函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88"><span class="toc-number">9.1.</span> <span class="toc-text">对象指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">9.2.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">函数参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">抽象，封装和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Scope-of-Data-Members-in-Class-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.1.</span> <span class="toc-text">The Scope of Data Members in Class (数据成员的作用域)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hidden-by-same-name-%E5%90%8C%E5%90%8D%E5%B1%8F%E8%94%BD"><span class="toc-number">10.2.</span> <span class="toc-text">Hidden by same name (同名屏蔽)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">类数据成员的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">基本初始化方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">11.2.</span> <span class="toc-text">类的初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Default-Constructor-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">Default Constructor  默认构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F"><span class="toc-number">11.4.</span> <span class="toc-text">初始化次序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string%E7%B1%BB%E5%92%8Cstd-array%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">string类和std::array类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-C-string-Class"><span class="toc-number">12.1.</span> <span class="toc-text">The C++ string Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">数组类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-11%E6%96%AD%E8%A8%80%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">c++11断言和常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%A3%B0%E6%98%8E%E5%8F%AF%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E6%88%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">13.1.1.</span> <span class="toc-text">constexpr说明符声明可在编译时计算函数或变量的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E4%B8%8EC-11%E7%9A%84%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-number">13.2.</span> <span class="toc-text">断言与C++11的静态断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">13.3.</span> <span class="toc-text">声明与定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%9E%84%E9%80%A0"><span class="toc-number">14.</span> <span class="toc-text">代理构造</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">不可变对象和类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">16.</span> <span class="toc-text">实例成员与静态成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%90%E6%9E%84"><span class="toc-number">17.</span> <span class="toc-text">析构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%EF%BC%88c-%E7%8B%AC%E6%9C%89%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">友元（c++独有）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.</span> <span class="toc-text">深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">19.1.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">19.2.</span> <span class="toc-text">隐式声明的拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.3.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.4.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E6%96%B9%E5%A4%9C%E8%B0%AD%EF%BC%9A"><span class="toc-number">19.5.</span> <span class="toc-text">天方夜谭：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">vector类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">21.</span> <span class="toc-text">C++14: 字符串字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E2%80%9C%E5%8E%9F%E5%A7%8B-%E7%94%9F%E2%80%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">21.1.</span> <span class="toc-text">C++11“原始&#x2F;生”字符串字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-14%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">21.2.</span> <span class="toc-text">C++14的字符串字面量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E8%BF%9B%E9%98%B6"><span class="toc-number">22.</span> <span class="toc-text">编码规范进阶</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-number">23.</span> <span class="toc-text">结构化绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="toc-number">23.1.</span> <span class="toc-text">用于数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">23.2.</span> <span class="toc-text">用于对象数据成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">24.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">C++11：继承中的构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E9%93%BE%E5%92%8C%E6%9E%90%E6%9E%84%E9%93%BE"><span class="toc-number">26.</span> <span class="toc-text">构造链和析构链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%93%BE"><span class="toc-number">26.1.</span> <span class="toc-text">构造函数链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%93%BE"><span class="toc-number">26.2.</span> <span class="toc-text">析构函数链</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%90%8D%E5%AD%97%E9%9A%90%E8%97%8F"><span class="toc-number">27.</span> <span class="toc-text">继承中的名字隐藏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">28.</span> <span class="toc-text">重定义函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">29.</span> <span class="toc-text">多态的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-number">29.1.</span> <span class="toc-text">实现运行时多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%EF%BC%9A%E4%BD%BF%E7%94%A8override%E5%92%8Cfinal"><span class="toc-number">30.</span> <span class="toc-text">C++11：使用override和final</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#override%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E8%A6%86%E5%86%99"><span class="toc-number">30.1.</span> <span class="toc-text">override显式声明覆写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%A6%81%E6%AD%A2%E8%A6%86%E5%86%99"><span class="toc-number">30.2.</span> <span class="toc-text">final 显式声明禁止覆写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E5%8F%AF%E8%A7%81%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-number">31.</span> <span class="toc-text">访问控制 (可见性控制)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#the-private-and-public-keywords"><span class="toc-number">31.1.</span> <span class="toc-text">the private and public keywords</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8B"><span class="toc-number">31.2.</span> <span class="toc-text">访问属性示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">31.3.</span> <span class="toc-text">公有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">31.4.</span> <span class="toc-text">私有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">31.5.</span> <span class="toc-text">保护继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">32.</span> <span class="toc-text">抽象类与纯虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E7%B1%BB%E5%A4%AA%E6%8A%BD%E8%B1%A1%E4%BB%A5%E8%87%B3%E4%BA%8E%E6%97%A0%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B0%B1%E5%8F%AB%E5%81%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">32.1.</span> <span class="toc-text">抽象类:类太抽象以至于无法实例化就叫做抽象类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">33.</span> <span class="toc-text">动态类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-cast-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">33.1.</span> <span class="toc-text">dynamic_cast 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Upcasting-and-Downcasting-%E5%90%91%E4%B8%8A-%E5%90%91%E4%B8%8B-%E8%BD%AC%E5%9E%8B"><span class="toc-number">33.2.</span> <span class="toc-text">Upcasting and Downcasting (向上&#x2F;向下 转型)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E8%BD%AC%E5%8F%AF%E4%B8%8D%E4%BD%BF%E7%94%A8dynamic-cast%E8%80%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">33.2.1.</span> <span class="toc-text">上转可不使用dynamic_cast而隐式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">33.3.</span> <span class="toc-text">对象内存布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typeid-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">34.</span> <span class="toc-text">typeid  运行时查询类型的信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-17%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">35.</span> <span class="toc-text">C++17的文件系统库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#About-std-filesystem"><span class="toc-number">35.1.</span> <span class="toc-text">About std::filesystem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Some-terms-%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD"><span class="toc-number">35.1.1.</span> <span class="toc-text">Some terms(一些术语)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E7%B1%BB%EF%BC%9A"><span class="toc-number">35.1.2.</span> <span class="toc-text">路径类：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E7%B1%BB%E5%8F%8A%E6%93%8D%E4%BD%9C"><span class="toc-number">36.</span> <span class="toc-text">路径类及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#path%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">36.1.</span> <span class="toc-text">path类的成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">36.2.</span> <span class="toc-text">非成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction-to-the-Input-and-Output-Classes"><span class="toc-number">37.</span> <span class="toc-text">Introduction to the Input and Output Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#between-C-and-C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%AF%94"><span class="toc-number">37.1.</span> <span class="toc-text">between C and C++ (文件操作对比)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">37.2.</span> <span class="toc-text">流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">37.3.</span> <span class="toc-text">带缓冲的输入输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">38.</span> <span class="toc-text">向文件写入数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">39.</span> <span class="toc-text">从文件读数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">40.</span> <span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%AE%BD%E2%80%9D%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">40.1.</span> <span class="toc-text">“设置域宽”控制符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E8%AE%BE%E7%BD%AE%E6%B5%AE%E7%82%B9%E7%B2%BE%E5%BA%A6%E2%80%9D%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">40.2.</span> <span class="toc-text">“设置浮点精度”控制符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6%E2%80%9D%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">40.3.</span> <span class="toc-text">“设置填充字符”控制符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">40.4.</span> <span class="toc-text">在文件操作中格式化输入&#x2F;输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">41.</span> <span class="toc-text">用于输入&#x2F;输出流的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#getline"><span class="toc-number">41.1.</span> <span class="toc-text">getline()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-and-put"><span class="toc-number">41.2.</span> <span class="toc-text">get() and put()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush"><span class="toc-number">41.3.</span> <span class="toc-text">flush()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">42.</span> <span class="toc-text">二进制文件输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">42.1.</span> <span class="toc-text">文件的打开模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%84%E5%90%88"><span class="toc-number">42.2.</span> <span class="toc-text">模式组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">42.3.</span> <span class="toc-text">二进制输入输出简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AF%BB%E5%86%99"><span class="toc-number">43.</span> <span class="toc-text">如何实现二进制读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">43.1.</span> <span class="toc-text">write函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E9%9D%9E%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">43.2.</span> <span class="toc-text">如何将非字符数据写入文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%BF%A1%E6%81%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">43.3.</span> <span class="toc-text">如何将信息转换为字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">43.4.</span> <span class="toc-text">read成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E6%8C%87%E7%A4%BA%E5%99%A8"><span class="toc-number">44.</span> <span class="toc-text">文件位置指示器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fp"><span class="toc-number">44.0.1.</span> <span class="toc-text">fp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">45.</span> <span class="toc-text">随机访问文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">46.</span> <span class="toc-text">运算符与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B8%80%E8%B5%B7%E7%94%A8%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">46.1.</span> <span class="toc-text">与对象一起用的运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">46.2.</span> <span class="toc-text">运算符与函数的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">46.2.1.</span> <span class="toc-text">不同之处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E4%B8%8A%E6%9C%89%E5%8C%BA%E5%88%AB"><span class="toc-number">46.2.1.1.</span> <span class="toc-text">语法上有区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%8F%AA%E8%83%BD%E9%87%8D%E8%BD%BD"><span class="toc-number">46.2.1.2.</span> <span class="toc-text">不能自定义新的运算符 (只能重载)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%AFoverload-override%E4%BA%A7%E7%94%9F%E4%BB%BB%E4%BD%95%E6%83%B3%E8%A6%81%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E4%BD%86%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9"><span class="toc-number">46.2.1.3.</span> <span class="toc-text">函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%82%E5%BF%B5"><span class="toc-number">46.2.2.</span> <span class="toc-text">函数式编程语言的观念</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/06/cmake/" title="cmake"><img src="/./iimmgg/green.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cmake"/></a><div class="content"><a class="title" href="/2023/11/06/cmake/" title="cmake">cmake</a><time datetime="2023-11-06T09:41:52.000Z" title="Created 2023-11-06 17:41:52">2023-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/31/conda-env/" title="WSL2+miniconda+Jupyter notebook"><img src="/./iimmgg/p5r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2+miniconda+Jupyter notebook"/></a><div class="content"><a class="title" href="/2023/10/31/conda-env/" title="WSL2+miniconda+Jupyter notebook">WSL2+miniconda+Jupyter notebook</a><time datetime="2023-10-31T03:05:00.000Z" title="Created 2023-10-31 11:05:00">2023-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/25/Linux%E6%8B%BE%E9%81%97/" title="Linux拾遗"><img src="/./iimmgg/linux.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux拾遗"/></a><div class="content"><a class="title" href="/2023/10/25/Linux%E6%8B%BE%E9%81%97/" title="Linux拾遗">Linux拾遗</a><time datetime="2023-10-25T15:09:00.000Z" title="Created 2023-10-25 23:09:00">2023-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/24/diary/" title="diary"><img src="/./iimmgg/20-12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="diary"/></a><div class="content"><a class="title" href="/2023/10/24/diary/" title="diary">diary</a><time datetime="2023-10-24T03:55:05.000Z" title="Created 2023-10-24 11:55:05">2023-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/10/docker/" title="docker"><img src="/./iimmgg/ylxr.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker"/></a><div class="content"><a class="title" href="/2023/10/10/docker/" title="docker">docker</a><time datetime="2023-10-10T09:32:54.000Z" title="Created 2023-10-10 17:32:54">2023-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./iimmgg/wallhaven-kw6v96.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 庄生晓梦</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><div class="aplayer no-destroy" data-id="2229469033" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-order="random"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body></html>