<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光琥珀</title>
  
  <subtitle>true</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-13T05:49:22.297Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>庄生晓梦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Games101总结</title>
    <link href="http://example.com/2023/09/12/games101%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/09/12/games101%E6%80%BB%E7%BB%93/</id>
    <published>2023-09-12T13:46:41.000Z</published>
    <updated>2023-09-13T05:49:22.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Games101总结"><a href="#Games101总结" class="headerlink" title="Games101总结"></a>Games101总结</h1><p>时隔两年，当初的很多东西都快遗失了，简单做一个笔记备份，彻底和本科阶段的学习做个告别</p><p>记录从前对图形学的热枕</p><h1 id="01-101"><a href="#01-101" class="headerlink" title="01 - 101"></a>01 - 101</h1><p>光栅化，几何，光线追踪，动画（模拟）</p><p><strong>相关学科</strong></p><ul><li>线性代数，微积分，统计</li><li>光学，力学</li><li>信号处理，数值分析</li><li>美学</li></ul><p><strong>线性代数</strong></p><p>向量点乘</p><p>向量叉乘：右手螺旋定则，例子：已知两轴确定坐标轴，判定左右内外</p><p><code>x×y=z</code>右手坐标系，<code>a×a=0</code>（0向量）</p><p>矩阵</p><p>矩阵*向量 变换</p><p>转置，逆，单位矩阵，伴随矩阵，向量乘法转矩阵形式（点乘和叉乘）</p><hr><h1 id="Games101-Transformation"><a href="#Games101-Transformation" class="headerlink" title="Games101-Transformation"></a>Games101-Transformation</h1><p><strong>提纲</strong></p><ul><li>Modeling</li><li>Viewing</li></ul><p><strong>scale缩放</strong></p><h1 id="left-begin-matrix-x’-y’-end-matrix-right"><a href="#left-begin-matrix-x’-y’-end-matrix-right" class="headerlink" title="$$\left[ \begin{matrix}   x’  \   y’  \end{matrix}\right]"></a>$$<br>\left[<br> \begin{matrix}<br>   x’  \<br>   y’<br>  \end{matrix}<br>\right]</h1><p>\left[<br> \begin{matrix}<br>   s_x &amp; 0 \<br>   0 &amp; s_y<br>  \end{matrix}<br>\right]<br>\left[<br> \begin{matrix}<br>   x  \<br>   y<br>  \end{matrix}<br>\right]<br>$$</p><p>scale matrix</p><p>$$<br>\left[<br> \begin{matrix}<br>   s_x &amp; 0 \<br>   0 &amp; s_y<br>  \end{matrix}<br>\right]<br>$$</p><p><strong>shear错切</strong></p><p><strong>rotate旋转</strong></p><h1 id="left-begin-matrix-x’-y’-end-matrix-right-1"><a href="#left-begin-matrix-x’-y’-end-matrix-right-1" class="headerlink" title="$$\left[ \begin{matrix}   x’  \   y’  \end{matrix}\right]"></a>$$<br>\left[<br> \begin{matrix}<br>   x’  \<br>   y’<br>  \end{matrix}<br>\right]</h1><p>\left[<br> \begin{matrix}<br>   a &amp; b \<br>   c &amp; d<br>  \end{matrix}<br>\right]<br>\left[<br> \begin{matrix}<br>   x  \<br>   y<br>  \end{matrix}<br>\right]<br>$$</p><p><strong>平移</strong></p><p>不是线性变换</p><p><strong>齐次坐标</strong></p><p>$$<br>point&#x3D;(x,y,1)^T<br>\<br>vector&#x3D;(x,y,0)<br>$$</p><p>向量平移不变性</p><ul><li>逆变换：逆矩阵</li><li>变换的顺序很重要，矩阵乘法的顺序不满足交换律</li><li>多个变换，矩阵往左附加，n个变换矩阵可以合成一个矩阵以表示一个复杂变换</li><li>变换分解，</li></ul><p>3D Transformations</p><p>$$<br>point&#x3D;(x,y,z,1)^T<br>\<br>vector&#x3D;(x,y,z,0)<br>\<br>$$</p><p><strong>前置知识</strong></p><p>正交矩阵</p><p>$$<br>A^T &#x3D; A^{-1}<br>$$</p><p>旋转矩阵满足等式   $ R_{-θ}&#x3D;R_θ^T&#x3D;R_θ^{-1} $</p><p><strong>3D Transformation</strong></p><p>对二维矩阵扩展，加入 z 轴（或理解成加入一个维度），例子如下</p><p>Scale Matrix：$\left[\begin{matrix}S_x &amp; 0 &amp; 0 &amp; 0 \0&amp;S_y&amp;0&amp;0\0&amp;0&amp;S_z&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$</p><p>Translation：$\left[\begin{matrix}1&amp;0&amp;0&amp;t_x\0&amp;1&amp;0&amp;t_y\0&amp;0&amp;1&amp;t_z\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$</p><p><strong>3D Rotation</strong></p><ul><li>绕轴旋转</li></ul><p>$$\left[\begin{matrix}1&amp;0&amp;0&amp;0\0&amp;cosθ&amp;-sinθ&amp;0\0&amp;sinθ&amp;cosθ&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$$</p><p>$$\left[\begin{matrix}cosθ&amp;0&amp;sinθ&amp;0\0&amp;1&amp;0&amp;0\-sinθ&amp;0&amp;cosθ&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$$</p><p>$$\left[\begin{matrix}cosθ&amp;-sinθ&amp;0&amp;0\sinθ&amp;cosθ&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$$</p><p>对任何3D旋转：$R_{xyz}(\alpha,\beta,\gamma)&#x3D;R_x(\alpha)R_y(\beta)R_z(\gamma)$</p><p><strong>MVP变换</strong></p><ul><li>modeling</li><li>viewing</li><li>projection</li></ul><p><strong>Viewing Transformation</strong></p><p>- </p><p>3个参数 $\vec e$</p><p>固定相机位置</p><p>任意位置相机移动至**原点 (0,0,0)<strong>，方向朝</strong><code>-z</code>**方向，角度对 <strong>Y 轴</strong></p><p>先平移$\left[\begin{matrix}1&amp;0&amp;0&amp;-X_e\0&amp;1&amp;0&amp;-Y_e\0&amp;0&amp;1&amp;-Z_e\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$</p><p>再旋转（旋转矩阵如何表示？）</p><ul><li>当前位置直接求矩阵很困难</li><li>利用旋转矩阵的正交性</li><li>求出坐标系到的当前旋转角度的旋转矩阵M</li><li>$M^{-1}&#x3D;M^T$</li></ul><p><strong>Projection Transformation</strong></p><p>立方体：<code>[l,r]*[b,t]*[f,n]</code>（左右，上下，前后，对相机来说n &gt; f）</p><p><strong>正交变换（Orthographic Transformation）</strong></p><p>投影到$[-1,1]^3$范围内，本质是将任意位置的物体，表示在固定距离角度的空间或平面上</p><p>通过平移+放缩实现，立方体为例</p><ul><li>几何中心移动至原点</li><li>放缩至$[-1,1]^3$</li></ul><p>$M_{ortho}&#x3D;\left[\begin{matrix}\frac{2}{r-l}&amp;0&amp;0&amp;0\0&amp;\frac{2}{t-b}&amp;0&amp;0\0&amp;0&amp;\frac{2}{n-f}&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]\left[\begin{matrix}1&amp;0&amp;0&amp;-\frac{l+r}{2}\0&amp;1&amp;0&amp;-\frac{b+t}{2}\0&amp;0&amp;1&amp;-\frac{n+f}{2}\0&amp;0&amp;0&amp;1\ \end{matrix}\right]$</p><ul><li>注意<code>n-f</code></li></ul><p><strong>透视变换（Perspective Transformation）</strong></p><p>···</p><hr><h1 id="shadows，光栅化补充"><a href="#shadows，光栅化补充" class="headerlink" title="shadows，光栅化补充"></a>shadows，光栅化补充</h1><p>阴影映射 | 阴影图</p><p>shadow mapping</p><p>不在阴影里的点：相机能看到，光源也能看到</p><p>在阴影里的点：只有相机能看到</p><p>只讨论点光源</p><p>硬阴影：阴影边缘非常锐利，点光源</p><hr><ol><li>从光源看向场景，记录看到的任何点的深度</li><li>从相机看向场景，同上，然后投影回光源，判断是否能同时被看到</li></ol><p>软阴影：边缘逐渐消失，光源有一定的大小</p><hr><h1 id="Games101-Geometry"><a href="#Games101-Geometry" class="headerlink" title="Games101 Geometry"></a>Games101 Geometry</h1><h3 id="纹理续"><a href="#纹理续" class="headerlink" title="纹理续"></a>纹理续</h3><p>现代GPU中，纹理&#x3D;内存+范围查询（滤波），即可以理解为一块数据</p><h4 id="环境光（Environmental-Lighting）"><a href="#环境光（Environmental-Lighting）" class="headerlink" title="环境光（Environmental Lighting）"></a>环境光（Environmental Lighting）</h4><p>可以用纹理描述环境光，并拿去渲染表示环境光的效果</p><p>但是现实中随着人的走动光照位置会发生变化，所以上述方式是不考虑深度信息的近似方法</p><h4 id="Spherical-Environmental-Map"><a href="#Spherical-Environmental-Map" class="headerlink" title="Spherical Environmental Map"></a>Spherical Environmental Map</h4><p>将环境光记录在球体中，再展开</p><p>扭曲问题：参考世界地图</p><h4 id="Cube-Map"><a href="#Cube-Map" class="headerlink" title="Cube Map"></a>Cube Map</h4><p>将球之于一个立方体中，从球心向外做投影，得到6张图，解决扭曲</p><h4 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h4><p>纹理定义法线方向的相对高度</p><p>在不改变几何信息的情况下，可以通过复杂的纹理来表示复杂的结构</p><p>相对高度变化-法线变化-着色变化，产生明暗变化</p><p>由于没有改变几何，所以物体边缘会暴露（很光滑）</p><h4 id="位移贴图"><a href="#位移贴图" class="headerlink" title="位移贴图"></a>位移贴图</h4><p>真的移动顶点位置，</p><p>描述几何体的三角形要足够多</p><h4 id="3D贴图"><a href="#3D贴图" class="headerlink" title="3D贴图"></a>3D贴图</h4><p>定义三维空间中的一个任意点</p><p>通过噪声函数生成空间中任意点的数据</p><h4 id="3D纹理和体积渲染"><a href="#3D纹理和体积渲染" class="headerlink" title="3D纹理和体积渲染"></a>3D纹理和体积渲染</h4><p>医学</p><h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>隐式，显式</p><p>隐式表示：</p><p>方程，难看出表示什么，但可以方便的判断是否在表面上</p><p>显式：直接或参数映射</p><p>参数映射，二维映射到三维</p><h4 id="CSG（Constructive-Solid-Geometry）"><a href="#CSG（Constructive-Solid-Geometry）" class="headerlink" title="CSG（Constructive Solid Geometry）"></a>CSG（Constructive Solid Geometry）</h4><p>通过基本几何体的变换，布尔计算，得到复杂几何体</p><h4 id="Distance-Function"><a href="#Distance-Function" class="headerlink" title="Distance Function"></a>Distance Function</h4><p> 代替布尔运算，通常使用<strong>距离函数</strong>使表面融合</p><p>空间中的任意一点到物体表面的任意一点的最小距离？（理解不能）</p><p>蜗牛，蘑菇，瓢虫等等都可以用距离函数表示，没有几何形体，一种隐式表示</p><p>分离物体：距离函数为0的就是物体表面（水平集level sets）</p><p><strong>分形</strong>Fractals</p><p>渲染时会引起强烈的走样，因为变化频率太高</p><hr><h1 id="相机，透镜，光场"><a href="#相机，透镜，光场" class="headerlink" title="相机，透镜，光场"></a>相机，透镜，光场</h1><p><strong>针孔摄像机</strong>：无法记录深度信息，任意位置都是锐利的，没有虚化</p><p><strong>视场（FOV）</strong>：成像面的长度h和透镜的距离f<br>$$<br>FOV&#x3D;2arctan(\frac{h}{2f})<br>$$<br>市场上焦距和FOV参数以35mm大小的胶片为标准</p><hr><p><strong>Exposure曝光度</strong></p><p>H&#x3D;T*E，T由快门控制，E由光圈大小，ISO增益等决定</p><p>time*irradiance</p><p>ISO不但增强了有效信息还放大了噪声信息</p><hr><p>lens </p><p>假设对于一个透镜，其焦距可以任意修改<br>$$<br>物距：z_o \<br>像距：z_i\<br>\frac{1}{f}&#x3D;\frac{1}{z_i}+\frac{1}{z_o}<br>$$</p><hr><p>Circle of Confusion（CoC）Size</p><p>感光元件在焦点后面，会投射在一个圆内，A就是光圈大小，A越大，C越大模糊</p><hr><p>可以模拟薄透镜来实现景深效果</p><p><strong>Light Field &#x2F; Lumigraph</strong></p><p>任意位置任意方向的光</p><hr><h1 id="Materials-and-Appearance"><a href="#Materials-and-Appearance" class="headerlink" title="Materials and Appearance"></a>Materials and Appearance</h1><p>由渲染方程可知，BRDF决定了材质</p><p>透明、半透明材质，考虑反射和折射</p><p>光线得折射反射，使能量发生变化从而使某些材质显示出一定的颜色</p><hr><p><strong>折射</strong></p><p>BTDF</p><p>还是用几何光学分析</p><p>水底条状纹理，聚焦，光线正好聚焦到同一点</p><p>斯涅耳定律，折射定律</p><p>不同材料的折射率不同</p><hr><p>入射介质和出射介质，折射角可能无意义，出现全反射现象</p><p>斯涅尔窗</p><hr><p>BSTF（散射）&#x3D;BRDF（反射）+BTDF（折射）</p><hr><p><strong>菲涅尔项</strong></p><p>不同角度的反射能量不同</p><p>光和物体越平行，越多能量被反射</p><p>金属材质的菲涅尔项在垂直使仍然能达到0.9+</p><hr><p><strong>微表面模型</strong></p><p>物体表面粗糙，但当距离足够远时，就是材质和外观，就如墙面忽略了其表面微小的凹 凸</p><hr><p>各向同性：微表面分布基本均匀</p><p>各向异性：微表面的法线分布有明确的方向性（各种人造金属制品，锅，光盘，尼龙等）</p><hr><h1 id="GAMES101-Geometry（Curves-and-Surfaces）"><a href="#GAMES101-Geometry（Curves-and-Surfaces）" class="headerlink" title="GAMES101 - Geometry（Curves and Surfaces）"></a>GAMES101 - Geometry（Curves and Surfaces）</h1><p><strong>Point Cloud</strong></p><p>大力出奇迹</p><p>只要点够密，可以表示任何东西</p><p>难点：如何将一堆点表示表面</p><p><strong>Polygon Mesh</strong></p><p>多边形网格，最广泛使用</p><p>难点：如何组合多边形</p><p>一堆点v，一堆法线vn，一堆纹理坐标vt存到文本文件，</p><p>一个立方体8个点，6个面6个法线，存储时会去除冗余</p><p><code>f 5/1/1 1/2/1 4/3/1</code>，三个点确定一个三角形，共用一条法线</p><p><code>点/纹理坐标/法线</code></p><hr><p><strong>Bezier Curve</strong></p><p>每条线段看作一条路径，假定可以控制时间t，找出时间t所处的点</p><p>任意一个时间t都可以找出对应的点</p><p>通过点的位置和时间t能找出所求点的代数表示</p><p>三维空间同样适用</p><p>仿射不变性：仿射变换下，只要对控制点做仿射变换</p><p>凸包性质：Bezier曲线一定在控制点形成的凸包（最小的凸多边形）内</p><hr><p>控制点过多就不容易控制曲线形状，且动一个点整条曲线都会变化</p><p>逐段，一般每段3阶4个点，绘图软件钢笔工具</p><p>C<sup>0</sup>连续，几何上接触</p><p>C<sup>1</sup>连续，一阶导数相等，光滑</p><p>C<sup>2</sup>连续，二阶导数…</p><p>如何保证曲线连接处光滑？切线导数相同，控制点距离一样</p><p><strong>spline样条</strong></p><p>可控曲线</p><p><strong>B-splines</strong></p><p>由不同的基函数控制…</p><p>Bezier曲线的扩展，有局部性</p><p><strong>NURBS</strong></p><p>对B样条的进一步扩展</p><hr><p><strong>Bezier Surfaces</strong></p><p>两个方向分别运用Bezier Curve，曲线扫过的空间就形成一个曲面</p><hr><h1 id="GAMES101-曲面细分"><a href="#GAMES101-曲面细分" class="headerlink" title="GAMES101 - 曲面细分"></a>GAMES101 - 曲面细分</h1><p><strong>细分Mash</strong></p><p>引入更多三角形，同时位置发生变化使之更加光滑</p><p><strong>loop细分</strong></p><p>只能用于三角形网格</p><p><code>(1-n*u)*原位置+u*领近点位置平均</code></p><p>n:顶点的度</p><p>u:权？</p><p><strong>Catmull-Clark subdivision</strong></p><p>适用于任意形状的网格</p><p>术语：四边形面，非四边形面，奇异点（度不为4的点）</p><p>将边上的中点和面的中点都连起来，变为都是四边形的网格（所以一次细分后奇异点不再增加），奇异点增加（非四边形面中心点一定是奇异点）</p><hr><p>不同场合选择合适数量的网格</p><hr><p><strong>网格简化</strong></p><p><strong>边坍缩</strong></p><p>边变顶点</p><p><strong>二次误差度量</strong></p><p>最小化二次误差，将点放置到合适的位置，使得对原图的影响最小</p><p>从二次误差度量最小的边开始坍缩，优先队列或堆，贪心算法（局部最优）</p><hr><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><p>早期关键帧技术</p><p><strong>基于物理的动画</strong></p><p>Mass Spring System，质点弹簧系统</p><p>FEM,有限元</p><hr><p><strong>Particle Systems 粒子系统</strong></p><p>将粒子一个个的定义出来，设定粒子间的相互作用力，引力和斥力，粒子间的相互作用力符合什么规律最后表现的就想什么</p><p>通过一些函数，表现粒子突然生成，突然消失，定义粒子的速度和位置 </p><p>包括流体，烟云等都可以模拟</p><hr><p><strong>运动学</strong></p><p>骨骼</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Games101总结&quot;&gt;&lt;a href=&quot;#Games101总结&quot; class=&quot;headerlink&quot; title=&quot;Games101总结&quot;&gt;&lt;/a&gt;Games101总结&lt;/h1&gt;&lt;p&gt;时隔两年，当初的很多东西都快遗失了，简单做一个笔记备份，彻底和本科阶段的学习</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Graphics" scheme="http://example.com/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>SGI STL内存配置器分析</title>
    <link href="http://example.com/2021/12/11/SGI%20STL%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/12/11/SGI%20STL%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8%E5%88%86%E6%9E%90/</id>
    <published>2021-12-11T12:04:00.000Z</published>
    <updated>2023-09-13T05:52:32.001Z</updated>
    
    <content type="html"><![CDATA[<p>stl的容器利用缺省的Alloc参数为自己分配内存，Alloc就是stl的空间配置器，用于空间的管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;&#125;</span><br></pre></td></tr></table></figure><p>空间配置器由<strong>内存池</strong>，<strong>链表</strong>来具体实现对空间的<strong>分配</strong>、<strong>回收</strong>和<strong>管理</strong></p><hr><p>在一个对象的创建和销毁时(<code>new</code>和<code>delete</code>)，各需要经历了两个步骤</p><p>创建</p><ul><li>分配空间</li><li>用构造函数构造对象</li></ul><p>销毁</p><ul><li>析构</li><li>释放空间</li></ul><p>注意区分<code>::operator new</code>和<code>placement new</code></p><hr><p>进一步抽象，就像房子和内部物体结构，同样可以在上面的步骤中，将空间管理和具体结构管理分开</p><p>见框架图</p><hr><p>构造：调用<code>placement new</code>在指定的位置上设定初值</p><p>析构：析构指定位置的东西</p><hr><h3 id="空间的管理"><a href="#空间的管理" class="headerlink" title="空间的管理"></a>空间的管理</h3><p>使用一块内存而不加管理会导致很多问题，诸如向系统堆栈（system heap）请求空间，内存不足，内存碎片等</p><p>针对内存碎片，有<strong>双层级配置器</strong></p><p>对于内存不足和请求system heap，有<strong>内存池</strong>（memory pool）</p><hr><p>为什么不只用一级配置器，malloc似乎也可以分配小空间？</p><p>防止过多的额外负担（overhead），每向系统申请一块内存，就有一部分其他的空间被系统拿来管理我们申请的那片内存，申请内存越小，系统管理所用空间占比就越大，举例就是去离家很近的地方，选择走路而不是开车，走路不用花钱，开车却有一定的花费，这个花费对这点距离来说没有必要，但是出远门，开车肯定比走路好，这些花费是必要的</p><hr><p>总结做了一个框架图来展示SGI alloc的实现</p><p><img src="/iimmgg/sgialloc.png" alt="关系图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;stl的容器利用缺省的Alloc参数为自己分配内存，Alloc就是stl的空间配置器，用于空间的管理&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Inside The C++ Object Model简单记录</title>
    <link href="http://example.com/2021/11/25/Inside_C++_Obj_Model/"/>
    <id>http://example.com/2021/11/25/Inside_C++_Obj_Model/</id>
    <published>2021-11-25T04:05:00.000Z</published>
    <updated>2023-09-12T10:23:33.571Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为阅读《Inside The C++ Object Model》时对其中相对重要的 data 语义和 function 语义的一些记录</p><hr><h2 id="data语义"><a href="#data语义" class="headerlink" title="data语义"></a>data语义</h2><ul><li><p>编译器一般将多个access sections连锁在一起形成一个区块，这个操作不会降低效率，诸如多个public域</p></li><li><p>C\C++的边界调整有可能会在中间插入若干bit（类似c的结构体内存对齐）</p></li><li><p>编译器会自动生成一些内容以支撑对象例如vptr，一般vptr会被插入对象的开头或结尾，依赖编译器的处理</p></li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static data member 不从属于class</span></span><br><span class="line"><span class="comment">// 对其的引用会得到一个指向其数据类型的指针,如下</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> st_con = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> pt = &amp;Test::st_con; <span class="comment">//pt is const int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这时，当两个class都有同名static data member则会产生冲突，此时编译器为每个static data member编码（<strong>name-mangling</strong>），用以区分彼此</p><hr><p>nonstatic data member在存取时和C的效率没什么两样，是C++从C中借鉴过来的一部分</p><p>存取需要通过明指或暗指（this）</p><hr><p>但当用<strong>指针</strong>且继承结构中存在<strong>虚拟继承</strong>时就无法在编译阶段确定成员属于何对象（虚拟继承不常用，可忽略）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.x;</span><br><span class="line">pt-&gt;x;<span class="comment">//pt指向需要在执行阶段才能判断</span></span><br></pre></td></tr></table></figure><hr><p>派生类赋值给基类(但vs似乎避免了这个情况？)，会将非继承成员放到基类因内存对齐而填充的空间中，此时基类结构发生改变，这时当另一个基类给当前基类赋值时，基类结构中的子类成员会被未知数据填充</p><hr><p>vptr在尾部就兼容C，在头部更有利于多继承，vs中vptr被插入至头部，例子见下</p><p>单继承体系中把一个派生类地址给基类指针是一个自然过程，但在vptr在头部且派生类中含有虚函数时就需要编译器介入，多继承+虚拟继承就更需要了</p><p>多重继承，在指针变化时内部会进行计算以获得目标基类的offset(编译器介入)</p><p>编译器优化之后，封装不会对执行期效率产生什么影响</p><h2 id="function-语意"><a href="#function-语意" class="headerlink" title="function 语意"></a>function 语意</h2><p>类成员函数有3种状态：<code>static, nonstatic, vitual</code></p><p>类内函数成员在编译器的优化后可以获得不低于外部函数的效率，会被编译器优化成了类外部函数实体</p><hr><p><strong>vitual member function</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用指针对虚函数的调用</span></span><br><span class="line">ptr-&gt;<span class="built_in">fun</span>();</span><br><span class="line"><span class="comment">// 会转化为</span></span><br><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr);<span class="comment">// 通过ptr获取虚表中的函数指针，通过函数指针调用虚函数</span></span><br></pre></td></tr></table></figure><p><strong>C++多态：以一个基类指针或引用寻址出一个派生类对象</strong></p><p>如何在执行期确定虚函数的实体？</p><ul><li>具体是哪个类（指针或引用指向的真实类型）</li><li>哪个虚函数（虚函数地址）</li></ul><p>如何存放两个需要的信息？</p><ul><li>一个由编译器提供的vptr指针，指向vitual table，其中存储了type_info for object和 虚函数的执行期地址</li><li>为了找到函数地址，每个虚函数被指定一个索引（纯虚函数同样有自己的索引</li></ul><p>在编译时虚函数由其对象调用可知，由编译器完全控制，唯一一个在执行期才知道的消息是：slot指向的函数实体</p><p><strong>指针的类型是定义时确定的，但指向的对象的类型不确定</strong>，诸如：<code>base *p = &amp;child;</code>其中p是基类指针，但可以指向派生类对象，对象信息存放在virtual table中的RTT字段，运行时确定</p><hr><ul><li><p>非成员函数，成员函数、静态函数被编译器优化成<strong>完全相同</strong>的形式，函数效率相同</p></li><li><p>加上vitual后，随继承结构复杂度耗时增加</p></li></ul><hr><p><strong>普通成员函数</strong></p><p>同数据成员一样，直接是在内存中的真正地址，需要依赖于对象访问</p><hr><p><strong>inline</strong></p><p>是**#define的一种安全替代品**，但仍然需要被小心处理，过多的参数（产生临时变量）和嵌套会导致扩展码大量增加或无法扩展开来</p><p>inline函数有惊人的效率，被视作不变表达式，编译器将其提出至循环之外，只计算一次</p><hr><p><strong>类结构实例研究</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> _a, <span class="type">char</span> _b) : <span class="built_in">a</span>(_a) , <span class="built_in">b</span>(_b) &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_fun_0</span><span class="params">()</span> </span>&#123;&#125;;<span class="comment">//有一个4B的指针</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_fun_1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//4B</span></span><br><span class="line"><span class="type">char</span> b;<span class="comment">//1B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TT</span> : <span class="keyword">public</span> Test &#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">TT</span>(<span class="type">int</span> _a, <span class="type">char</span> _b, <span class="type">char</span> _c) : <span class="built_in">Test</span>(_a, _b), <span class="built_in">c</span>(_c) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun_1</span><span class="params">()</span> </span>&#123;&#125;;<span class="comment">//override</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TT_fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类与派生类结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----vs编译后的内存布局-----//</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;<span class="function"><span class="keyword">class</span> Test<span class="title">size</span><span class="params">(<span class="number">12</span>)</span>:// 基类,<span class="number">12</span>字节</span></span><br><span class="line"><span class="function"><span class="number">1</span>&gt;+---</span></span><br><span class="line"><span class="function"><span class="number">1</span>&gt; <span class="number">0</span>| &#123;</span>vfptr&#125;<span class="comment">// 4字节指针,指向虚表 ;且位于头部，不兼容C</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">4</span>| a    <span class="comment">// int,4字节</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">8</span>| b    <span class="comment">// char,1字节</span></span><br><span class="line"><span class="number">1</span>&gt;  | &lt;alignment member&gt; (size=<span class="number">3</span>)<span class="comment">//内存对齐</span></span><br><span class="line"><span class="number">1</span>&gt;+---</span><br><span class="line"><span class="number">1</span>&gt;Test::$vftable@:<span class="comment">//虚表结构</span></span><br><span class="line"><span class="number">1</span>&gt;| &amp;Test_meta<span class="comment">//用于支持RTTI的类型信息</span></span><br><span class="line"><span class="number">1</span>&gt;|  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">0</span>| &amp;Test::vir_fun_0<span class="comment">//索引 0</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">1</span>| &amp;Test::vir_fun_1<span class="comment">//索引 1</span></span><br><span class="line"><span class="number">1</span>&gt;Test::vir_fun_0 <span class="keyword">this</span> adjustor: <span class="number">0</span><span class="comment">//调节器：用于多重继承中,获取夹在第一基类和派生类中间的基类开始地址</span></span><br><span class="line"><span class="number">1</span>&gt;Test::vir_fun_1 <span class="keyword">this</span> adjustor: <span class="number">0</span><span class="comment">//就是一个偏移量，如果中间还有一个基类,则第二基类开始在12字节后（Test占12字节）</span></span><br><span class="line"><span class="number">1</span>&gt;<span class="function"><span class="keyword">class</span> TT<span class="title">size</span><span class="params">(<span class="number">16</span>)</span>://派生类，<span class="number">16</span>字节 =</span> 基类<span class="number">12B</span> + <span class="built_in">sizeof</span>(<span class="type">char</span>) + 内存对齐<span class="number">3</span>字节</span><br><span class="line"><span class="number">1</span>&gt;+---</span><br><span class="line"><span class="number">1</span>&gt; <span class="number">0</span>| +--- (base <span class="keyword">class</span> Test)<span class="comment">//基类保持其结构不变,用于内存对齐的空间仍然存在</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">0</span>| | &#123;vfptr&#125;   <span class="comment">//派生类继续使用基类的虚表指针，从此可得vptr在头部有利于OOP的继承机构</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">4</span>| | a</span><br><span class="line"><span class="number">1</span>&gt; <span class="number">8</span>| | b</span><br><span class="line"><span class="number">1</span>&gt;  | | &lt;alignment member&gt; (size=<span class="number">3</span>)<span class="comment">//基类中的内存对齐空间任然存在</span></span><br><span class="line"><span class="number">1</span>&gt;| +---</span><br><span class="line"><span class="number">1</span>&gt;<span class="number">12</span>| c<span class="comment">//子类数据成员</span></span><br><span class="line"><span class="number">1</span>&gt;  | &lt;alignment member&gt; (size=<span class="number">3</span>)<span class="comment">//内存对齐</span></span><br><span class="line"><span class="number">1</span>&gt;+---</span><br><span class="line"><span class="number">1</span>&gt;TT::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;| &amp;TT_meta</span><br><span class="line"><span class="number">1</span>&gt;|  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">0</span>| &amp;Test::vir_fun_0<span class="comment">//索引0,派生类没有处理,直接继承基类虚函数</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">1</span>| &amp;TT::vir_fun_1<span class="comment">//索引1,基类虚函数被派生类override</span></span><br><span class="line"><span class="number">1</span>&gt; <span class="number">2</span>| &amp;TT::TT_fun<span class="comment">//索引2,派生类新的虚函数，表被扩展</span></span><br><span class="line"><span class="number">1</span>&gt;TT::vir_fun_1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;TT::TT_fun <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此篇为阅读《Inside The C++ Object Model》时对其中相对重要的 data 语义和 function 语义的一些记录&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;data语义&quot;&gt;&lt;a href=&quot;#data语义&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SpeedTree导入UE后花叶丢失问题解决</title>
    <link href="http://example.com/2021/10/28/speedtree/"/>
    <id>http://example.com/2021/10/28/speedtree/</id>
    <published>2021-10-28T08:21:19.000Z</published>
    <updated>2023-09-13T05:56:05.501Z</updated>
    
    <content type="html"><![CDATA[<p>版本问题，speedtree7的树库导入speedtree8后会出bug，据说会在下一个版本解决</p><p>解决方法就是ue4中<strong>把贴图的alpha通道直接连接到opacity</strong></p><hr><p>通过修改</p><p><img src="/iimmgg/20211028-162845.jpg" alt="20211028-162845"></p><p>修改成：</p><p><img src="/iimmgg/20211028-162902.jpg" alt="20211028-162902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;版本问题，speedtree7的树库导入speedtree8后会出bug，据说会在下一个版本解决&lt;/p&gt;
&lt;p&gt;解决方法就是ue4中&lt;strong&gt;把贴图的alpha通道直接连接到opacity&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通过修改&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="ue4" scheme="http://example.com/tags/ue4/"/>
    
  </entry>
  
  <entry>
    <title>C++高级宏操作</title>
    <link href="http://example.com/2021/10/14/C++%E9%AB%98%E7%BA%A7%E5%AE%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/10/14/C++%E9%AB%98%E7%BA%A7%E5%AE%8F%E6%93%8D%E4%BD%9C/</id>
    <published>2021-10-14T14:30:00.000Z</published>
    <updated>2023-09-13T05:59:20.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-高级宏操作"><a href="#C-高级宏操作" class="headerlink" title="C++高级宏操作"></a>C++高级宏操作</h1><p>最近在看一个c++各数据类型和 JSON 或 xml 互转的库，重点阅读了其中宏的编写</p><p><a href="https://github.com/xyz347/xpack">xpack项目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体格式如下</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">long</span> uid;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">XPACK</span>(<span class="built_in">A</span>(uid, <span class="string">&quot;id&quot;</span>), <span class="built_in">O</span>(name));<span class="comment">//用于指示各变量的特殊操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XPACK(...)   \</span></span><br><span class="line"><span class="meta">    X_PACK_COMMON    \</span></span><br><span class="line"><span class="meta">    X_PACK_DECODE_BEGIN X_PACK_N(X_PACK_L1, X_PACK_L1_DECODE, __VA_ARGS__) &#125;  \</span></span><br><span class="line"><span class="meta">    X_PACK_ENCODE_BEGIN X_PACK_N(X_PACK_L1, X_PACK_L1_ENCODE, __VA_ARGS__) &#125;</span></span><br></pre></td></tr></table></figure><p>结构体中的变量数目不定，采用可变参数宏：</p><p><code>...</code>和<code>__VA_ARGS__</code>配合使用，<code>...</code>处填充的内容将填充到<code>___VA_ARGS__</code>处</p><p><code>__VA_ARGS__</code>替换最后一个具体参数后所有内容包括逗号等</p><p>当然c++并不提倡使用可变参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_COMMON \</span></span><br><span class="line"><span class="meta">public:               \</span></span><br><span class="line"><span class="meta">    static bool const __x_pack_value = true;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_DECODE_BEGIN                         \</span></span><br><span class="line"><span class="meta">    template<span class="string">&lt;class __X_PACK_DOC, class __X_PACK_ME&gt;</span> \</span></span><br><span class="line"><span class="meta">    void __x_pack_decode(__X_PACK_DOC&amp; __x_pack_obj, __X_PACK_ME &amp;__x_pack_self, const xpack::Extend *__x_pack_extp) &#123;(void)__x_pack_extp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// encode function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_ENCODE_BEGIN                          \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;class __X_PACK_DOC, class __X_PACK_ME&gt;</span> \</span></span><br><span class="line"><span class="meta">    void __x_pack_encode(__X_PACK_DOC&amp; __x_pack_obj, const __X_PACK_ME &amp;__x_pack_self, const xpack::Extend *__x_pack_extp) const &#123;(void)__x_pack_extp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这里开始可以看出XPACK已经被展开成了一个静态常量和两个函数，<code>x_PACK_N()</code>被包在函数内部</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_N(LEVEL, ACTION, ...)  X_PACK_COUNT(LEVEL, ACTION, __VA_ARGS__, _99,_98,_97,_96,_95,_94,_93,_92,_91,_90,_89,_88,_87,_86,_85,_84,_83,_82,_81,_80,_79,_78,_77,_76,_75,_74,_73,_72,_71,_70,_69,_68,_67,_66,_65,_64,_63,_62,_61,_60,_59,_58,_57,_56,_55,_54,_53,_52,_51,_50,_49,_48,_47,_46,_45,_44,_43,_42,_41,_40,_39,_38,_37,_36,_35,_34,_33,_32,_31,_30,_29,_28,_27,_26,_25,_24,_23,_22,_21,_20,_19,_18,_17,_16,_15,_14,_13,_12,_11,_10,_9,_8,_7,_6,_5,_4,_3,_2,_1) (ACTION, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_COUNT(LEVEL, ACTION, _99,_98,_97,_96,_95,_94,_93,_92,_91,_90,_89,_88,_87,_86,_85,_84,_83,_82,_81,_80,_79,_78,_77,_76,_75,_74,_73,_72,_71,_70,_69,_68,_67,_66,_65,_64,_63,_62,_61,_60,_59,_58,_57,_56,_55,_54,_53,_52,_51,_50,_49,_48,_47,_46,_45,_44,_43,_42,_41,_40,_39,_38,_37,_36,_35,_34,_33,_32,_31,_30,_29,_28,_27,_26,_25,_24,_23,_22,_21,_20,_19,_18,_17,_16,_15,_14,_13,_12,_11,_10,_9,_8,_7,_6,_5,_4,_3,_2,_1,N,...) LEVEL##N</span></span><br></pre></td></tr></table></figure><p>很离谱第一次看到这种操作，算是奇技淫巧了，分析一下做了什么</p><p>举个例子：<code>x_PACK_N(L,A, myA, myY)</code>扩展成<code>X_PACK_COUNT(L, A, myX, myY, 一坨)(ACTION, __VA_ARGS__)</code></p><p><code>X_PACK_COUNT(L, A, myX, myY, -99, 一坨, _3, _2, _1)</code></p><p><code>X_PACK_COUNT(L, A, _99, _98, 一坨, _2, _1, N)</code></p><p><code>N</code>获取到<code>_2</code></p><p>这个宏相当于是一个截取功能，理解成一个窗口</p><p>这一步的结果是<code>X_PACK_L1_2(X_PACK_L1_DECODE, __VA_ARGS__)</code></p><p>注意：此方法适用于gcc，msvc中需要再添加一个宏<code>#define EXPAND(...) __VA_ARGS__</code>，并且包含在<code>X_PACK_COUNT()</code>之外</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPEND(X_PACK_COUNT()) EXPEND(ACTION, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><hr><p>后面经过几步简单的变换转换成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X_PACK_L1_DECODE</span>(<span class="built_in">A</span>(uid, <span class="string">&quot;id&quot;</span>)) <span class="built_in">X_PACK_L1_DECODE</span>(<span class="built_in">O</span>(name))</span><br></pre></td></tr></table></figure><p>再来看一下<code>X_PACK_L1_DECODE</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////// XPACK /////////////////////////////</span></span><br><span class="line"><span class="comment">//=======DECODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE(x)             &#123; X_PACK_L1_DECODE_##x &#125;</span></span><br><span class="line"><span class="comment">//----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_X(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_DECODE_ACT_O, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_E(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_DECODE_ACT_E, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_B(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_DECODE_ACT_B, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_AF(FLAG, ...)  X_EXPAND_FLAG_##FLAG X_PACK_N2(X_PACK_L2_2, X_PACK_DECODE_ACT_A, __VA_ARGS__) <span class="comment">// extend define in ACTION</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_O(...)         X_PACK_L1_DECODE_X(F(0), __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_M(...)         X_PACK_L1_DECODE_X(F(M), __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_A(...)         X_PACK_L1_DECODE_AF(F(0), __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_DECODE_I(...)         X_PACK_N2(X_PACK_L2, X_PACK_DECODE_ACT_I, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">//=======ENCODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE(x) &#123; X_PACK_L1_ENCODE_##x &#125;</span></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_X(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_ENCODE_ACT_O, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_E(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_ENCODE_ACT_E, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_B(FLAG, ...)   X_EXPAND_FLAG_##FLAG xpack::Extend __x_pack_ext(__x_pack_flag, NULL); X_PACK_N2(X_PACK_L2, X_PACK_ENCODE_ACT_B, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_AF(FLAG, ...)  X_EXPAND_FLAG_##FLAG X_PACK_N2(X_PACK_L2_2, X_PACK_ENCODE_ACT_A, __VA_ARGS__) <span class="comment">// extend define in ACTION</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_O(...)         X_PACK_L1_ENCODE_X(F(0), __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_M(...)         X_PACK_L1_ENCODE_X(F(M), __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_A(...)         X_PACK_L1_ENCODE_AF(F(0), __VA_ARGS__)</span></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_L1_ENCODE_I(...)         X_PACK_N2(X_PACK_L2, X_PACK_ENCODE_ACT_I, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>很明显可以看出：用<code>##</code>来实现switch逻辑</p><p><code>X_PACK_L1_DECODE(A(uid, &quot;id&quot;))</code>扩展成<code>&#123;X_PACK_L1_DECODE_A(uid, &quot;id&quot;)&#125;</code></p><hr><p>后面的操作大同小异，经过几次扩展后从转为N2同时L1转为L2再转成<code>X_PACK_ACT</code>类型的宏，最后由如下的宏转换成最终代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ decode act ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_DECODE_ACT_O(M)                        \</span></span><br><span class="line"><span class="meta">        __x_pack_ext.vsize = sizeof(__x_pack_self.M); \</span></span><br><span class="line"><span class="meta">        __x_pack_obj.decode(#M, __x_pack_self.M, &amp;__x_pack_ext);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enum for not support c++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_DECODE_ACT_E(M)                        \</span></span><br><span class="line"><span class="meta">        __x_pack_ext.vsize = sizeof(__x_pack_self.M); \</span></span><br><span class="line"><span class="meta">        __x_pack_obj.decode(#M, *((int*)&amp;__x_pack_self.M), &amp;__x_pack_ext);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_PACK_DECODE_ACT_A(M, NAME)                                      \</span></span><br><span class="line"><span class="meta">    &#123;                                                                     \</span></span><br><span class="line"><span class="meta">        static xpack::Alias __x_pack_alias(#M, NAME);                     \</span></span><br><span class="line"><span class="meta">        xpack::Extend __x_pack_ext(__x_pack_flag, &amp;__x_pack_alias);       \</span></span><br><span class="line"><span class="meta">        const char *__new_name = __x_pack_alias.Name(__x_pack_obj.Type());\</span></span><br><span class="line"><span class="meta">        __x_pack_ext.vsize = sizeof(__x_pack_self.M);                     \</span></span><br><span class="line"><span class="meta">        __x_pack_obj.decode(__new_name, __x_pack_self.M, &amp;__x_pack_ext);  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-高级宏操作&quot;&gt;&lt;a href=&quot;#C-高级宏操作&quot; class=&quot;headerlink&quot; title=&quot;C++高级宏操作&quot;&gt;&lt;/a&gt;C++高级宏操作&lt;/h1&gt;&lt;p&gt;最近在看一个c++各数据类型和 JSON 或 xml 互转的库，重点阅读了其中宏的编写&lt;/p&gt;
</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Gamma校正详解</title>
    <link href="http://example.com/2021/08/23/Gamma%E6%A0%A1%E6%AD%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/08/23/Gamma%E6%A0%A1%E6%AD%A3%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-08-23T09:16:00.000Z</published>
    <updated>2023-09-13T06:01:36.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gamma校正详解"><a href="#Gamma校正详解" class="headerlink" title="Gamma校正详解"></a>Gamma校正详解</h1><p><a href="https://www.cambridgeincolour.com/tutorials/gamma-correction.htm">参考阅读</a></p><p><a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">LearnOpenGL</a></p><p>首先，物理上灰度的变化是平滑的，两倍的光子就产生两倍的灰度变化，是线性的，但是在人眼中就不同了，人眼对暗部更加敏感，是非线性的</p><p>打个比方就是<strong>在暗处 <strong>0.5 倍的物理光子变化，在人眼中可能变化了 2-3 倍，而</strong>在亮处</strong>，要让人感到 2 倍的亮度变化，光子可能需要增加 3-4 倍</p><p><img src="/iimmgg/gamma_correction_brightness.png" alt="gamma_correction_brightness"></p><p>如上图，线性空间（物理空间）中的 0.2 在人看来就是美术意义上的中灰</p><p><img src="/iimmgg/gamma_correction_gamma_curves.png" alt="gamma_correction_gamma_curves"></p><h2 id="简易的一个例子"><a href="#简易的一个例子" class="headerlink" title="简易的一个例子"></a>简易的一个例子</h2><p>假设自然界中一个 0.218 的灰度，在人眼中就是 0.5</p><p>用相机等光学元件记录时，记录的就是 0.218（大多数数码相机以线性方式记录光线）</p><p>经过 gamma 校正（gamma 编码），0.218 通过传递函数以 0.5 存储在硬盘中（这一步在现实中，由绘图软件本身做了，存储在 jpg 等格式的文件中）</p><p>显示时经 gamma2.2 压暗，以 0.218 的光显示，人眼中就是 0.5，和最开始直接观察一致</p><hr><ul><li>如果<strong>不校正</strong>直接存储在硬盘中，经过 gamma2.2 的压暗输出 0.035，人眼中就是 0.218，结果我们<strong>直接看到了线性空间</strong>，就是图一的第二行，导致图片的视觉效果非常亮，而且在人眼中的黑到灰被压缩到了 0.0-0.2，图片的暗部没有细节，而且从黑到白的过度非常生硬有跳跃感，下面是在 unity 中做的效果</li></ul><p><img src="/iimmgg/QQ图片20210822140930.png" alt="QQ图片20210822140930" style="zoom: 67%;" /><img src="/iimmgg/QQ图片20210822140945.png" alt="QQ图片20210822140945" style="zoom: 67%;" />  </p><p>左图Gamma校正，右图无Gamma校正，灰色过度几乎没了，由于只是简单的光照模型没用贴图，所以不能直观感受暗部的细节缺失</p><hr><h2 id="sRGB-贴图过曝问题"><a href="#sRGB-贴图过曝问题" class="headerlink" title="sRGB 贴图过曝问题"></a>sRGB 贴图过曝问题</h2><p>sRGB空间 在内存中就是 <code>1/2.2</code>的伽马编码，非线性的编码</p><p>当我们在渲染器中使用gamma校正后，就是对原图又进行了一次亮度提升，特别明显的是超出 1.0 的部分被截断在 1 导致大量的纯白</p><p>另一个就是混合操作时，直接拿非线性编码混合就出问题了，需要<strong>转换到线性空间下再参与计算</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line"><span class="type">vec3</span> linearColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(texture0, Texcoords).rgb, <span class="type">vec3</span>(gamma));</span><br></pre></td></tr></table></figure><hr><p>并非所有纹理实际上都在 sRGB 空间中。用于为对象着色的纹理（如漫反射纹理）几乎总是在 sRGB 空间中。用于检索光照参数的纹理（如镜面反射贴图和法线贴图）几乎总是在线性空间中</p><hr><h2 id="光照衰减"><a href="#光照衰减" class="headerlink" title="光照衰减"></a>光照衰减</h2><p>由于 gamma 校正的影响</p><p>一句话总结：线性空间用线性，伽马空间用物理方程</p><p>线性空间中用经验方程<br>$$<br>线性空间中的变化\frac{1}{D}<br>$$</p><p>$$<br>经过显示gamma后，显示亮度为\left(\frac{1}{D}\right)^{2.2}&#x3D;\frac{1}{D^{2.2}}，差不多2次幂<br>$$</p><hr><h2 id="unity对sRGB图像的处理"><a href="#unity对sRGB图像的处理" class="headerlink" title="unity对sRGB图像的处理"></a>unity对sRGB图像的处理</h2><p>贴图选项勾选 sRGB 在采样时就将伽马空间中的数值转到线性空间中了（重校），经过着色器操作，最后输出到屏幕之前通过 sRGB Frame Buffer 进行 gamma 校正以平衡显示器的显示gamma</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gamma校正详解&quot;&gt;&lt;a href=&quot;#Gamma校正详解&quot; class=&quot;headerlink&quot; title=&quot;Gamma校正详解&quot;&gt;&lt;/a&gt;Gamma校正详解&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cambridgeincolour.com</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Graphics" scheme="http://example.com/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>PBR 基础</title>
    <link href="http://example.com/2021/07/27/PBR/"/>
    <id>http://example.com/2021/07/27/PBR/</id>
    <published>2021-07-27T04:14:53.000Z</published>
    <updated>2023-09-13T06:03:38.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前渲染流水线中的光照模型都是<strong>经验模型</strong>，为了渲染更真实的物体就有了基于物理的渲染 PBR</p><hr><p>光在介质中传播，发生吸收和散射</p><p>当介质的密度发生变化时，产生反射和折射</p><p><strong>所以光照射到物体上时，一部分发生反射（高光反射），一部分发生折射，而折射光一部分被吸收，一部分被散射到外部（次表面散射，漫反射）</strong></p><hr><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>双向反射分布函数</p><p>用于解释物体表面一点和光作用的函数</p><p>定义为某微面元单位时间内接受的能量经表面材质交互后往特定方向（立体角）辐射的能量<br>$$<br>定义：f(l,v) &#x3D; \frac{dL(v)}{dE(l)}<br>$$</p><hr><p>辐射率（radiance）：单位面积，单位方向上的光源辐射通量，用<code>L</code>表示</p><p>辐照度（irradiance）：单位面积上的光源辐射通量，用<code>E</code>表示</p><ul><li>两个量都可以理解为单位时间内的能量，因为都是从功率推过来的</li><li>由定义可知：$E&#x3D;\int_\Omega Ld\omega$</li></ul><hr><p>主要描述表面反射和次表面散射</p><p><strong>表面反射</strong>：高光反射</p><p><strong>次表面散射</strong>：漫反射，折射的光中一部分被<strong>吸收</strong>一部分被<strong>重新散射到外部</strong></p><hr><h2 id="反射等式"><a href="#反射等式" class="headerlink" title="反射等式"></a>反射等式</h2><p>$$<br>L_o&#x3D;\int_\Omega f(l, v)*L_i(l)(n·l)d\omega_i<br>$$</p><p>很好理解，$L_i(l)(n·l)$就是<strong>入射方向的辐射率在投射到当前点后，该点所接收到的辐射率</strong></p><p>$f(l, v)$就是BRDF，计算光和表面交互后的出射率</p><p>单条光线如此，则<strong>对立体角求积分</strong>就可得最终结果</p><p><a href="https://www.zhihu.com/question/20085326?sort=created">立体角参考https://www.zhihu.com/question/20085326?sort=created</a></p><hr><p>$f(l, v)$是基于物理的，满足<strong>能量守恒</strong>和<strong>交换律</strong>（光路可逆）</p><p>$$<br>能量守恒：\forall l,\int_\Omega f(l, v)(n·l)d\omega_i&lt;&#x3D;1<br>$$</p><p>$$<br>交换律：f(l,v)&#x3D;f(v,l)<br>$$</p><hr><h3 id="漫反射项"><a href="#漫反射项" class="headerlink" title="漫反射项"></a>漫反射项</h3><p>如果表面没材质，那么不用考虑那么多，就是反射光与入射方向和观察方向无关，且反射光在半球面内均匀分布，就是应用最广泛的 <strong>Lambert BRDF</strong></p><p>$$<br>f_{Lambert}(l,v)&#x3D;\frac{c_{diff}}{\pi}<br>$$<br>Lambert BRDF的推导网上有很好的参考 ，$\pi$ 而不是$2\pi$是因为光源投影到表面时，irradiance会由于<strong>不垂直于表面</strong>而<strong>衰减</strong>$cos\theta$（本质是面积变化了)，对半球立体角积分时$\int_{\Omega}cos\theta sin\theta d\omega i$，积分结果为$\pi$</p><hr><p><strong>精确光源</strong></p><p>和上面的推导一样，半球面立体角积分积分<br>$$<br>L_o&#x3D;\pi f(l, v)*c_{light}(n·l)<br>$$</p><hr><p><strong>Disney BRDF</strong> 考虑了粗糙度和能量衰减<br>$$<br>f_{diff}&#x3D;\frac{baseColor}{\pi}(1+(F_{D90}-1)(1-n·l)^5)(1+(F_{D90}-1)(1-n·v)^5)<br>$$</p><p>$$<br>F_{D90}&#x3D;0.5 + 2roughness(h·l)^2<br>$$</p><hr><h3 id="高光反射项"><a href="#高光反射项" class="headerlink" title="高光反射项"></a>高光反射项</h3><p>建立在<strong>微面元理论</strong>上，当然这也是一个近似，一些材质无法用微面元来描述</p><p>微面元就是物体表面存在微小的突起，但宏观来说物体表面依旧是光滑的，<strong>微面元的法线和平滑的表面法线不尽相同</strong></p><ul><li>条件[1]：一部分微面元的<strong>法线正好是入射方向和观察方向的半角矢量</strong>，从而形成高光</li><li>条件[2]：但是这部分光可能在入射或反射过程中被其他面元<strong>遮挡</strong>，<strong>不纳入高光计算</strong></li></ul><p>分析是微观的，最终计算是宏观的</p><hr><p><strong>Torrance-Sparrow 微面元模型</strong><br>$$<br>f_{spec}(l, v)&#x3D;\frac{F(l,h)G(l,v,h)D(h)}{4(n·l)(n·v)}<br>$$<br>本质就是微面元的数学描述</p><p><code>D(h)</code>: <strong>法线分布函数</strong>，计算的满足条件[1]的微面元比例，常见的分布模型，Blinn-Phone、GGX、Beckmann</p><p><code>G(l,v,h)</code>: <strong>阴影-遮掩函数</strong>，计算的剔除条件[2]的微面元比例，获取活跃（有效）微面元所占比例（浓度）</p><p><code>F(l,h)</code>: <strong>菲涅尔反射反射函数</strong>，反射光占入射光的比例（菲涅尔等式）</p><p>分母是校正因子</p><hr><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>物体除了反射光外还有<strong>自发光</strong><br>$$<br>L_o&#x3D;L_e+\int_\Omega f(l, v)*L_i(l)(n·l)d\omega_i<br>$$</p><h2 id="金属和非金属"><a href="#金属和非金属" class="headerlink" title="金属和非金属"></a>金属和非金属</h2><p><strong>金属材质</strong></p><ul><li>强烈的高光反射，且呈现材质颜色</li><li>吸收系数很高</li><li>极大部分的折射光都被内部的自由电子吸收而迅速转化成其他的能量，即基本没有漫反射（次表面散射）</li></ul><p><strong>非金属材质</strong></p><ul><li>漫反射颜色多样</li><li>高光反射颜色单一</li><li>掠射角处反射增强，菲涅尔现象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;之前渲染流水线中的光照模型都是&lt;strong&gt;经验模型&lt;/strong&gt;，为了渲染更真实的物体就有了基于物理的渲染 PBR&lt;/p&gt;
&lt;hr&gt;</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Unity 屏幕后处理及原理</title>
    <link href="http://example.com/2021/07/25/Unity%20%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2021/07/25/Unity%20%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/</id>
    <published>2021-07-25T04:21:53.000Z</published>
    <updated>2023-09-13T06:05:06.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后处理原理及过程"><a href="#后处理原理及过程" class="headerlink" title="后处理原理及过程"></a>后处理原理及过程</h2><p>后处理是在渲染完后对图像进行处理，unity使用的是 <code>C#</code> 脚本</p><p>就是渲染完后不显示，多走一步，经由脚本处理后再显示到屏幕上，以实现诸如各种模糊效果、Bloom、描边等等</p><hr><p><strong>后处理一般过程</strong></p><p>获取当前屏幕图像，利用<code>C#</code>脚本调用<code>shader</code>对图像进行处理，在将处理后的图像显示到屏幕上</p><p><strong>原理</strong></p><p>创建了一个同屏幕宽高完全一样的面，将之前的渲染结果作为渲染纹理传入脚本，调用<code>shader</code>对纹理采样渲染回面片</p><p>所以在后处理时需要<strong>关闭深度写入</strong>等，防止渲染纹理覆盖了特殊情况下最后渲染的半透明物体</p><hr><p>Unity提供了<code>OnRenderImage() </code>函数获取屏幕图像</p><p><code>MonoBehaviour.OnRenderImage (RenderTexture src, RenderTexture dest)</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OnRenderImage中利用Graphics.Blit实现处理*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Blit</span>(<span class="params">Texture src, Texture dest</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Blit</span>(<span class="params">Texture src, Texture dest, Material mat, <span class="built_in">int</span> pass = <span class="number">-1</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Blit</span>(<span class="params">Texture src, Material mat, <span class="built_in">int</span> pass = <span class="number">-1</span></span>)</span>;</span><br></pre></td></tr></table></figure><p><code>Blit</code>函数获取屏幕图像后调用<code>shader</code>，将源图像<code>src</code>作为一张<strong>渲染纹理</strong>赋值给<code>shader</code>中<code>_MainTex</code></p><h2 id="边缘检测-描边"><a href="#边缘检测-描边" class="headerlink" title="边缘检测(描边)"></a>边缘检测(描边)</h2><p><strong>梯度</strong>的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）</p><p>二维空间下的偏微分方程<br>$$<br>\frac{∂f(x,y)}{∂x}&#x3D;\lim_{\epsilon-&gt;0}\frac{f(x+\epsilon,y)-f(x,y)}{\epsilon}<br>$$</p><p>$$<br>\frac{∂f(x,y)}{∂y}&#x3D;\lim_{\epsilon-&gt;0}\frac{f(x,y+\epsilon)-f(x,y)}{\epsilon}<br>$$</p><p>由于像素不是连续的，只要计算当前像素沿偏微分方向的差值，ε&#x3D;1，所以只需进行简单的加减运算</p><p>在xy得到的值经过勾股定理后就得到，二维空间下灰度的变化率</p><p><strong>边缘检测算子</strong></p><p><img src="/iimmgg/edge_detection_kernel.png" alt="edge_detection_kernel"></p><p><strong>注意：图中后两个算子是错的，xy方向反了！！！</strong></p><p>一般不采用 Roberts 这样偶数的算子，因为结果对原像素存在偏移</p><hr><p>Prewitt：$Gx &#x3D; f(x+1) + 0 * f(x)-f(x-1)$，提取系数就是<code>[-1, 0, 1]</code> </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所以该算子Gx就是：     同理Gy：</span><br><span class="line">[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>][<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>][ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>][ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>Sobel就是<code>prewitt</code>的基础上，加强了对直线上像素的检测</p><h2 id="高斯模糊和-Bloom-效果"><a href="#高斯模糊和-Bloom-效果" class="headerlink" title="高斯模糊和 Bloom 效果"></a>高斯模糊和 Bloom 效果</h2><p><strong>均值模糊</strong></p><p>卷积核的各元素值相同，<code>n*n</code>的核每个的值就是<code>1/n^2</code></p><p><strong>高斯模糊</strong></p><p>高斯模糊的卷积核又叫高斯核</p><p>高斯模糊的名字来源于高斯分布（正态分布），其概率密度函数所表示的就是均值与样本值之间的关系，所以高斯模糊就是一种权值按距离减少的方法<br>$$<br>G(x,y)&#x3D;\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}<br>$$<br>$\mu$就是0，因为当前像素的原点距离为0，方差$\sigma$取标准方差1</p><p><code>n*n</code> 的高斯核可以使用两个一维的高斯核替换</p><p>而且由于概率密度函数是对称的，所以存储上可以优化</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Shader*/</span></span><br><span class="line">_MainTex获取屏幕图像</span><br><span class="line">_MainTex_TexelSize获取纹素尺寸</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*计算纹理坐标*/</span></span><br><span class="line">half2 uv[<span class="number">5</span>] : TEXCOORDS0</span><br><span class="line">    <span class="comment">//Vertical</span></span><br><span class="line">    uv[<span class="number">0</span>]=uv;</span><br><span class="line">uv[<span class="number">1</span>]=uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize * <span class="number">1.0</span>);<span class="comment">//上方一格的坐标</span></span><br><span class="line">uv[<span class="number">2</span>]=uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize * <span class="number">1.0</span>);<span class="comment">//下方一格的坐标</span></span><br><span class="line">uv[<span class="number">3</span>]=uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize * <span class="number">2.0</span>);<span class="comment">//上方两格的坐标</span></span><br><span class="line">uv[<span class="number">4</span>]=uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize * <span class="number">2.0</span>);<span class="comment">//下方两格的坐标</span></span><br><span class="line"><span class="comment">//horizontal同理</span></span><br></pre></td></tr></table></figure><p><strong>Bloom效果</strong></p><p>步骤：提取图像中的亮部（像素的亮度可由<code>rgb</code>通过一定比例的计算获得），对提取的亮部进行高斯模糊，混合原图和Bloom</p><p><code>luminance = 0.2125 * r + 0.7154 * g + 0.0721 * b</code>，可以看出绿色对亮度的贡献最大，红色次之，蓝色最小</p><h2 id="运动模糊"><a href="#运动模糊" class="headerlink" title="运动模糊"></a>运动模糊</h2><p>方法：累计缓存（混合多张图像），速度缓存（按照像素的运动速度来模糊处理）</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一般格式*/</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader MyScriptShader;</span><br><span class="line">    <span class="keyword">private</span> Material MyScriptMaterial = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Material material &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">        MyScriptMaterial = function(MyScriptShader, MyScriptMaterial);</span><br><span class="line">        <span class="keyword">return</span> MyScriptMaterial;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暴露的属性</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> temp = <span class="number">3</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//调用shader</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRangeImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.setFloat(<span class="string">&quot;_temp&quot;</span>, temp);</span><br><span class="line">            <span class="comment">//后处理</span></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接返回</span></span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后处理原理及过程&quot;&gt;&lt;a href=&quot;#后处理原理及过程&quot; class=&quot;headerlink&quot; title=&quot;后处理原理及过程&quot;&gt;&lt;/a&gt;后处理原理及过程&lt;/h2&gt;&lt;p&gt;后处理是在渲染完后对图像进行处理，unity使用的是 &lt;code&gt;C#&lt;/code&gt; 脚本&lt;</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 透明效果</title>
    <link href="http://example.com/2021/07/11/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/"/>
    <id>http://example.com/2021/07/11/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</id>
    <published>2021-07-11T06:36:00.000Z</published>
    <updated>2023-09-13T06:07:49.565Z</updated>
    
    <content type="html"><![CDATA[<p>Unity 中实现透明效果一般有两种方法</p><h2 id="透明度测试（Alpha-Test）"><a href="#透明度测试（Alpha-Test）" class="headerlink" title="透明度测试（Alpha Test）"></a>透明度测试（Alpha Test）</h2><p><strong>原理：只要片元的透明度不符合要求就直接舍弃</strong></p><p><strong>不关闭深度写入（ZWrite）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;AlphaTest&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5 //控制剔除的阈值</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjection&quot;=&quot;True&quot; &quot;RanderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; </span><br><span class="line">            </span><br><span class="line">            Cull Off//用于双面渲染，不剔除背对摄像机的图元</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float3 worldNormal : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target&#123;</span><br><span class="line">                float3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                float3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                float4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                clip(texColor.a - _Cutoff);</span><br><span class="line">                //Equal to</span><br><span class="line">                //if( (texColor.a - _Cutoff) &lt; 0.0 )&#123;</span><br><span class="line">                //  discard;    </span><br><span class="line">                //&#125;</span><br><span class="line">                float3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                float3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                float3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透明度测试可以用于<strong>消解</strong>动画效果的实现</p><p><img src="/iimmgg/2021711-134249.jpg" alt="2021711-134249"></p><p><img src="/iimmgg/2021711-134837.jpg" alt="2021711-134837"></p><h2 id="透明度混合（Alpha-Blending）"><a href="#透明度混合（Alpha-Blending）" class="headerlink" title="透明度混合（Alpha Blending）"></a>透明度混合（Alpha Blending）</h2><p><strong>原理：当前片元的透明度作为混合参数与颜色缓冲中的颜色值混合</strong></p><p><strong>关闭深度写入，但不关闭深度测试</strong></p><hr><p>关闭深度写入将导致渲染顺序变得非常重要</p><p>一般做法：</p><ol><li>先渲染所有不透明物体，同时开启深度写入和深度测试</li><li>半透明物体按距离远近排序，然后从后往前渲染，开启深度测试，关闭深度写入</li></ol><p>由于排序是对于物体来说的，当物体间循环重叠时就需要用分割物体、分割网格的方法来解决</p><ul><li>尽可能让模型是凸面体</li><li>让透明通道更柔和，难以分辨</li><li>使用开启深度写入的半透明效果近似物体半透明</li></ul><hr><p>对于双面渲染的透明度混合，由于关闭了深度写入，在渲染时需要控制渲染顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjection&quot;=&quot;True&quot; &quot;RanderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">ZWrite Off</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha //开启混合模式，设定混合因子</span><br><span class="line">    </span><br><span class="line">Pass &#123;</span><br><span class="line">...</span><br><span class="line">Cull Front//剔除正面，渲染背面</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Pass &#123;</span><br><span class="line">...</span><br><span class="line">Cull Back//提出背面，渲染正面</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/iimmgg/2021711-135624.jpg" alt="2021711-135624"></p><p>半透明物体的阴影没了，暂时不知道原因</p><h2 id="深度写入的半透明效果"><a href="#深度写入的半透明效果" class="headerlink" title="深度写入的半透明效果"></a>深度写入的半透明效果</h2><p>使用两个 Pass</p><ul><li>第一个开启深度写入但不输出颜色</li><li>第二个进行透明度混合</li></ul><p>由于深度信息是对像素来说的，所以如果单个模型本身存在自我遮挡，那么被遮挡部分就直接舍弃了</p><p><code>ColorMask RGB | A | 0 | ...</code>表示当前 Pass 写入的颜色通道</p><h2 id="Unity预定义渲染队列"><a href="#Unity预定义渲染队列" class="headerlink" title="Unity预定义渲染队列"></a>Unity预定义渲染队列</h2><p>由<code>SubShader</code>的<code>Queue</code>标签定义:<code>Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;</code></p><table><thead><tr><th align="center">名称</th><th align="center">索引号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Background</td><td align="center">1000</td><td align="center"><strong>最先</strong>开始渲染的队列，一般用于绘制于背景上的物体</td></tr><tr><td align="center">Geometry</td><td align="center">2000</td><td align="center">默认队列，<strong>不透明物体</strong></td></tr><tr><td align="center">AlphaTest</td><td align="center">2450</td><td align="center"><strong>透明度测试</strong>，在不透明物体之后渲染可以更高效</td></tr><tr><td align="center">Transparent</td><td align="center">3000</td><td align="center"><strong>透明度混合</strong>，从后往前的顺序进行渲染</td></tr><tr><td align="center">Overlay</td><td align="center">4000</td><td align="center">用于<strong>最后</strong>渲染的物体，实现一些叠加效果</td></tr></tbody></table><p>索引号越小越早被渲染</p><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>混合不可编程但<strong>高度可配置</strong></p><p>混合<strong>源颜色</strong>（当前片元）和<strong>目标颜色</strong>（颜色缓冲）</p><ul><li><code>Blend SrcFactor DstFactor</code>: 只混合rgb通道</li><li><code>Blend SrcFactor DstFactor,SrcFactorA DstFactorA</code>: 上面的基础上，再混合 a 通道</li></ul><p>例子：</p><p><code>Blend SrcAlpha OneMinusSrcAlpha</code>：开启混合，并且混合结果是 $Src.a * Src.rgb + (1-Src.a)*Des.rgb$</p><hr><p>还可以配置<strong>混合操作</strong></p><p><code>BlendOp BlendOperation</code> </p><p>即改变源颜色和目标颜色最后的混合方式，默认为 Add</p><table><thead><tr><th align="center">操作</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Add</td><td align="center">加法</td></tr><tr><td align="center">Sub</td><td align="center">减法</td></tr><tr><td align="center">RevSub</td><td align="center">交换减法</td></tr><tr><td align="center">Min</td><td align="center">取各分量的最小值</td></tr><tr><td align="center">Max</td><td align="center">取各分量的最大值</td></tr></tbody></table><hr><p>同时使用上面两种方法可设定<strong>混合类型</strong></p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">正常</td><td align="center">Blend SrcAlpha OneMinusSrcAlpha</td></tr><tr><td align="center">柔和相加</td><td align="center">Blend OneMinusDstAlpha One</td></tr><tr><td align="center">正片叠底</td><td align="center">Blend DstColor Zero</td></tr><tr><td align="center">两倍相乘</td><td align="center">Blend DstColor SrcColor</td></tr><tr><td align="center">变暗</td><td align="center">BlendOp Min<br> Blend One One</td></tr><tr><td align="center">变亮</td><td align="center">BlendOp Max<br> Blend One One</td></tr><tr><td align="center">滤色</td><td align="center">Blend OneMinusDstColor One</td></tr><tr><td align="center">线性减淡</td><td align="center">Blend One One</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity 中实现透明效果一般有两种方法&lt;/p&gt;
&lt;h2 id=&quot;透明度测试（Alpha-Test）&quot;&gt;&lt;a href=&quot;#透明度测试（Alpha-Test）&quot; class=&quot;headerlink&quot; title=&quot;透明度测试（Alpha Test）&quot;&gt;&lt;/a&gt;透明度测试（A</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>MVP变换详解</title>
    <link href="http://example.com/2021/07/08/MVP/"/>
    <id>http://example.com/2021/07/08/MVP/</id>
    <published>2021-07-08T14:21:53.000Z</published>
    <updated>2023-09-13T06:15:18.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVP变换详解"><a href="#MVP变换详解" class="headerlink" title="MVP变换详解"></a>MVP变换详解</h1><p>之前学习中对这部分的理解不深，简单补了一遍线代，就又温习了一遍 MVP 变换</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MVP 变换简单来说就是将我们已经构建好的各种3维模型映射到屏幕这个2维坐标中， 参与 MVP 变换的信息包括点、矢量、法线、切线等</p><p>模型变换（Model）：将模型空间转换到世界空间</p><p>观察变换（View）：将世界空间转换到观察空间</p><p>投影变换（Projection）：将观察空间转换到裁剪空间</p><p>最后要获取屏幕坐标还需要一步：屏幕映射，又叫视口变换</p><p>屏幕映射：获取对应屏幕的 2D 坐标</p><p>《Shader 入门精要》的配图：<img src="/iimmgg/vertex_conversion.png" alt="vertex_conversion"  /></p><h2 id="模型变换-Model"><a href="#模型变换-Model" class="headerlink" title="模型变换(Model)"></a>模型变换(Model)</h2><p>本质就是旋转，平移，缩放（见本文最后）</p><p>模型自身会携带模型坐标的原点信息等，再结合世界坐标还是很好变换的</p><h2 id="观察变换-View"><a href="#观察变换-View" class="headerlink" title="观察变换(View)"></a>观察变换(View)</h2><p>在我的理解下，<code>M</code> 和 <code>V</code> 变换本质上是同一种类型的变换</p><p>比较快速的方法是把整个摄像机坐标空间移动到世界坐标使二者重合再反转 z 轴（不是真的移动摄像机），即在物体与摄像机相对位置不变的情况下让摄像机位于（0，0，0），将变换摄像机的矩阵作用于物体上就可得到观察空间中的坐标</p><p>ps：模型变换也能这么想</p><h2 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影(Projection)"></a>投影(Projection)</h2><p>投影要为裁剪做准备</p><p>视野是有限的，所以在视野外（视锥外）的东西是不需要显示的，而用六个裁剪平面（视锥的六个面）直接判断相对复杂，所以需要投影操作将视锥变成裁剪空间，再通过齐次除法，将裁剪空间变成CVV(Canonical View Volume)，OpenGL中CVV就是一个$[-1,1]^3$的正方体（下面讨论这种），DirectX中的 z 分量稍微不同是$[0,1]$，此时的坐标就是 NDC(Normalized Device Coordinates，归一化设备坐标)</p><p>不考虑 z 轴的情况下，投影是将所有点投影到近裁剪平面上（个人认为可以理解为摄像机拍到的画面，一张特殊的二维相片），然后放缩到$[-1,1]^2$的正方形平面</p><p>而 z 坐标，同样的放缩，但是还需要平移，因为旋向性改变了，z轴变正了（距离越远，z值越大）</p><p>所以投影阶段就已经将<code>x,y</code>坐标和<code>z</code>坐标（深度信息）割裂开来了，所谓的 CVV 可能是之前导致我困惑的一点，先分开分析再合并对我来说更好理解一些</p><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img src="/iimmgg/gl_projectionmatrix02.png" alt="gl_projectionmatrix02"></p><p>如上图，正交投影的“视锥”是一个长方体，可以通过六个参数定义 <code>right,left,top,bottom,near,far</code>分别对应了x,y,z轴上的范围（<strong>n和f是距离</strong>），从而构成一个长方体</p><p>正交投影的裁剪空间和齐次除法后的CVV是同一个东西就混着讲了</p><p>正交投影的XoY坐标不需要变化直接投射到近平面，然后缩放至$[-1,1]^2$<br>$$<br>M_{ortho}结构<br>\left[<br>\begin{matrix}<br>a&amp;0&amp;0&amp;0\<br>0&amp;b&amp;0&amp;0\<br>0&amp;0&amp;c&amp;d\<br>0&amp;0&amp;0&amp;1<br>\end{matrix}<br>\right]<br>$$<br>x,y是简单的放缩<br>$$<br>a·x&#x3D;\frac{x}{\frac{r-l}{2}}<br>$$</p><p>$$<br>a&#x3D;\frac{2}{r-l}<br>$$<br>y同理</p><p>$$<br>z考虑z_0&#x3D;-n,z_{normalized}&#x3D;-1<br>$$</p><p>$$<br>z_0&#x3D;-f,z_{normalized}&#x3D;1<br>$$</p><p>$$<br>\left{<br>    \begin{aligned}<br>        (-n)c+d&#x3D;-1\<br>        (-f)c+d&#x3D;1<br>    \end{aligned}<br>\right.<br>$$</p><p>$$<br>解得c&#x3D;-\frac{2}{f-n}<br>$$</p><h2 id="d-frac-f-n-f-n"><a href="#d-frac-f-n-f-n" class="headerlink" title="$$d&#x3D;-\frac{f+n}{f-n}$$"></a>$$<br>d&#x3D;-\frac{f+n}{f-n}<br>$$</h2><p>$$<br>M_{ortho}&#x3D;\left[\begin{matrix}\frac{2}{r-l}&amp;0&amp;0&amp;0\\0&amp;\frac{2}{t-b}&amp;0&amp;0\\0&amp;0&amp;-\frac{2}{f-n}&amp;-\frac{f+n}{f-n}\\0&amp;0&amp;0&amp;1 \end{matrix}\right]<br>$$</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><img src="/iimmgg/gl_projectionmatrix01.png" alt="gl_projectionmatrix01"  /><p>相对于正交投影，透视投影只是多了一条规则：近大远小，即 z 坐标越靠近近裁剪平面投影过来的 x,y 坐标受到的压缩更小</p><p>透视投影的视锥由4个参数定义，<code>near,far,FOV,Aspect</code>（FOV 有 FOVx 和 FOVy 之分，Aspect是宽高比 w:h）</p><p>对于 XOZ 和 YOZ 平面来说，如下图</p><p><img src="/iimmgg/gl_projectionmatrix03.png" alt="gl_projectionmatrix03" style="zoom: 50%;" /><img src="/iimmgg/gl_projectionmatrix04.png" alt="gl_projectionmatrix04" style="zoom: 50%;" /></p><p>从上图可知，对于 xy 坐标只需要放缩，同时 z 坐标全变为 -n，与xy也没有关系</p><p>所以矩阵结构大致如下<br>$$<br>M_{persp}&#x3D;\left[\begin{matrix}a&amp;0&amp;0&amp;0\0&amp;b&amp;0&amp;0\0&amp;0&amp;c&amp;d\e&amp;h&amp;g&amp;i\ \end{matrix}\right]<br>$$<br>投影完我们需要将把xy坐标压缩到$[-1,1]^2$范围内<br>$$<br>M_{persp}(x_e,y_e,z_e,1)&#x3D;(x’,y’,z_e’,1)<br>$$</p><p>$$<br>近平面width&#x3D;2·near·tan\frac{FOV_x}{2}<br>$$</p><p>$$<br>近平面height&#x3D;\frac{weight}{Aspect}&#x3D;2·near·tan\frac{FOV_x}{2}·\frac{1}{Aspect}<br>$$<br>变换后的坐标<br>$$<br>x’&#x3D;\frac{-nx_e}{z_e·n·tan\frac{FOV_x}{2}}&#x3D;-\frac{x_e}{z_e·tan\frac{FOV_x}{2}}<br>$$</p><p>$$<br>同理y’&#x3D;-\frac{y_e·Aspect}{z_e·tan\frac{FOV_x}{2}}<br>$$<br>但是由于 xy 的变换涉及到 $z_e$ 很难构建矩阵，所以利用齐次坐标赋予第4个变量其他意义</p><p>用数学表示就是让结果同时乘$-z_e$</p><p>$-z_e(x’,y’,z’,1)&#x3D;(-z_ex’,-z_ey’,-z_ez’,-z_e)$</p><p>明显可得<br>$$<br>a&#x3D;\frac{1}{\tan\frac{FOV_x}{2}}&#x3D;\cot\frac{FOV_x}{2}<br>$$</p><p>$$<br>b&#x3D;\frac{Aspect}{\tan\frac{FOV_x}{2}}&#x3D;Aspect·\cot\frac{FOV_x}{2}<br>$$</p><p>$$<br>e&#x3D;0 , h&#x3D;0 , i&#x3D;0 , g&#x3D;-1<br>$$<br>z轴的矩阵参数分析方法和正交一样<br>$$<br>\left{<br>\begin{aligned}<br>z_e&#x3D;-n,z’&#x3D;-1,-z_ez’&#x3D;z_e&#x3D;-n\<br>z_e&#x3D;-f,z’&#x3D;1,-z_ez’&#x3D;-z_e&#x3D;f<br>\end{aligned}<br>\right.<br>$$</p><p>$$<br>\left{<br>\begin{aligned}<br>(-n)c+d&#x3D;-n\<br>(-f)c+d&#x3D;f<br>\end{aligned}<br>\right.<br>$$</p><p>$$<br>解得<br>\left{<br>\begin{aligned}<br>c&#x3D;-\frac{f+n}{f-n}\<br>d&#x3D;-\frac{2nf}{f-n}<br>\end{aligned}<br>\right.<br>$$</p><hr><p>$$<br>M_{persp}&#x3D;\left[\begin{matrix}\cot\frac{FOV_x}{2}&amp;0&amp;0&amp;0\0&amp;Aspect·\cot\frac{FOV_x}{2}&amp;0&amp;0\0&amp;0&amp;-\frac{f+n}{f-n}&amp;-\frac{2nf}{f-n}\0&amp;0&amp;-1&amp;0\end{matrix}\right]<br>$$</p><p>$$<br>M_{persp}&#x3D;\left[\begin{matrix}\frac{\cot\frac{FOV_y}{2}}{Aspect}&amp;0&amp;0&amp;0\0&amp;\cot\frac{FOV_y}{2}&amp;0&amp;0\0&amp;0&amp;-\frac{f+n}{f-n}&amp;-\frac{2nf}{f-n}\0&amp;0&amp;-1&amp;0\end{matrix}\right]<br>$$<br>负号有无看<code>f-n</code>还是<code>n-f</code>，再强调一遍 n 和 f 是距离</p><p>从推导中可以看出，<strong>透视投影后的空间仍然是在一个锥体中</strong>(每个图元各自乘自己的 z 坐标)，这个空间是裁剪空间，所以可以认为先推导出 CVV 的公式再获得裁剪空间的变换矩阵<br>$$<br>裁剪空间的图元满足以下不等式，就保留<br>$$</p><p>$$<br>-z_e\leq x\leq z_e<br>$$</p><p>$$<br>-z_e\leq y\leq z_e<br>$$</p><p>$$<br>-z_e\leq z\leq z_e<br>$$</p><h2 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h2><p>这一步就要获取图元在屏幕上对应的像素坐标了</p><p>正交投影直接获得了 CVV（准确来说是裁剪空间和CVV一样，齐次除法后空间不变），而透视投影需要通过<strong>齐次除法</strong>（透视除法）来获得 CVV</p><p>明白透视投影矩阵的推导过程就很容易理解，透视投影的裁剪空间和 CVV 就差了一个乘除操作$-z_e$，而裁剪空间图元的第四个数就是$-z_e$，所以把裁剪空间图元的 xyz 除以第 4 个数就可获得其在 CVV 中的坐标了</p><hr><p>获得 CVV 后，z 坐标只用来判断深度大小，关注xy就行<br>$$<br>获取屏幕坐标矩阵&#x3D;\left[\begin{matrix}\frac{width}{2}&amp;0&amp;0&amp;\frac{width}{2}\0&amp;\frac{height}{2}&amp;0&amp;\frac{height}{2}\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\end{matrix}\right]<br>$$</p><h2 id="旋转，平移，缩放"><a href="#旋转，平移，缩放" class="headerlink" title="旋转，平移，缩放"></a>旋转，平移，缩放</h2><p>这部分的数学推导相对简单就不再赘述</p><p>左上 $3*3$ 的矩阵用于旋转和缩放，最后一列用于平移</p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>由于平移不是线性变换，所以采用齐次坐标（齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，是指一个用于投影几何里的坐标系统）<br>$$<br>点的移动\left[\begin{matrix}1&amp;0&amp;0&amp;t_x\0&amp;1&amp;0&amp;t_y\0&amp;0&amp;1&amp;t_z\0&amp;0&amp;0&amp;1\ \end{matrix}\right] · \left[\begin{matrix}x \y\z\1 \end{matrix}\right]&#x3D;\left[\begin{matrix}x+t_x\y+t_y\z+t_z\1\ \end{matrix}\right]<br>$$</p><p>$$<br>矢量移动\left[\begin{matrix}1&amp;0&amp;0&amp;t_x\0&amp;1&amp;0&amp;t_y\0&amp;0&amp;1&amp;t_z\0&amp;0&amp;0&amp;1\ \end{matrix}\right] · \left[\begin{matrix}x \y\z\0 \end{matrix}\right]&#x3D;\left[\begin{matrix}x\y\z\0\ \end{matrix}\right]<br>$$</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>$$<br>绕 x 轴： \left[\begin{matrix}1&amp;0&amp;0&amp;0\0&amp;cosθ&amp;-sinθ&amp;0\0&amp;sinθ&amp;cosθ&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]<br>$$</p><p>$$<br>绕 y 轴：\left[\begin{matrix}cosθ&amp;0&amp;sinθ&amp;0\0&amp;1&amp;0&amp;0\-sinθ&amp;0&amp;cosθ&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]<br>$$</p><p>$$<br>绕 z 轴：\left[\begin{matrix}cosθ&amp;-sinθ&amp;0&amp;0\sinθ&amp;cosθ&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]<br>$$</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>$$<br>\left[\begin{matrix}k_x&amp;0&amp;0&amp;0\0&amp;k_y&amp;0&amp;0\0&amp;0&amp;k_z&amp;0\0&amp;0&amp;0&amp;1\ \end{matrix}\right]<br>$$</p><p>$k_x&#x3D;k_y&#x3D;k_z$时为统一缩放</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVP变换详解&quot;&gt;&lt;a href=&quot;#MVP变换详解&quot; class=&quot;headerlink&quot; title=&quot;MVP变换详解&quot;&gt;&lt;/a&gt;MVP变换详解&lt;/h1&gt;&lt;p&gt;之前学习中对这部分的理解不深，简单补了一遍线代，就又温习了一遍 MVP 变换&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GAMES101-Ray Tracing</title>
    <link href="http://example.com/2021/05/26/GAMES101-13-Ray%20Tracing/"/>
    <id>http://example.com/2021/05/26/GAMES101-13-Ray%20Tracing/</id>
    <published>2021-05-26T14:28:00.000Z</published>
    <updated>2023-09-13T06:12:41.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAMES101-Ray-Tracing"><a href="#GAMES101-Ray-Tracing" class="headerlink" title="GAMES101-Ray Tracing"></a>GAMES101-Ray Tracing</h1><p>光栅化无法很好的控制全局效果，fast but quality is low</p><p>glossy reflection：对比铜镜</p><p>Indirect illumination：间接照明</p><hr><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>三个ideas</p><ul><li>光线沿<strong>直线传播</strong></li><li>光线之间<strong>不会发生碰撞</strong></li><li>光线<strong>来自light source</strong></li></ul><p>光线可逆</p><hr><p>eye ray</p><p>眼到每一个pixel的射线</p><hr><p><strong>Whitted-Style</strong></p><p>反射、折射</p><p>每一个弹射点的着色都会被算入 eye ray 的 pixel，每一个点都要判断是否能被照亮</p><p>primary ray，secondary ray，shadow ray</p><hr><p>光线：</p><p>由源点和方向向量定义</p><p>任意一点：<code>r(t) = O + td</code></p><p>和球的交点：点p同时满足光线方程和球方程</p><p>其他<strong>隐式表面</strong>同理</p><hr><p><strong>显式表面</strong>：和三角形求交</p><p>先求光线和平面交点，再判断是否在三角形内</p><p>平面：法线+点</p><p>MT算法：利用三角形重心坐标，直接求t</p><hr><p><strong>加速</strong></p><p>利用 bounding Volumes 包围盒</p><p>减少大量的光线和三角形交点计算</p><p>轴对齐包围盒（AABB，Axis-Aligned Bounding Box）</p><p>可求每对平面间光线的出入时间 t，求交集，非空则光线进入，进入的时间&lt;射出的时间</p><ul><li>离开时间&lt;0:无交点</li><li>离开&gt;0,进入&lt;0，光源在盒子里，有交点</li></ul><hr><h2 id="加速结构"><a href="#加速结构" class="headerlink" title="加速结构"></a>加速结构</h2><p>尽量做格子和光线的交</p><p>大规模空白集中物体场景就不适合均匀格子</p><hr><p><strong>空间划分</strong></p><p>物体密集处多分，稀疏处少分</p><p>Oct-Tree：8叉树，其中大部分是空白就可判断停止划分</p><p>KD-Tree：对Oct的优化，每次沿着某条轴砍一刀，水平竖直交替划分</p><p>BSP-Tree：</p><p>构造树形结构来存储物体（叶节点），中间节点存储其他信息</p><hr><p><strong>物体和包围盒</strong></p><p>判断物体是否在包围盒内很复杂，导致KD-Tree使用率变少</p><hr><h2 id="基于物体的划分-（Bounding-Volume-Hierarchy）BVH"><a href="#基于物体的划分-（Bounding-Volume-Hierarchy）BVH" class="headerlink" title="基于物体的划分 （Bounding Volume Hierarchy）BVH"></a>基于物体的划分 （Bounding Volume Hierarchy）BVH</h2><p>目前常用，解决了空间划分的问题</p><p>将物体分块，重新计算包围盒</p><ul><li>一个物体只在一个bounding box中</li><li>但是box会相交，尽可能让box间的重叠变少</li></ul><hr><h2 id="辐射度量"><a href="#辐射度量" class="headerlink" title="辐射度量"></a>辐射度量</h2><p>Blinn-Phone模型等都是做了极大的简化，渲染出的图依旧能很容易的判断真假</p><p>基于物理赋予光更具体的参数能带来更真实的渲染</p><hr><p>Radiant Energy：Q[J]</p><p>Flux(power)：功率,单位时间内通过某面的光子量，dQ&#x2F;dt [W&#x3D;Watt] [lm&#x3D;lumen]</p><hr><p><strong>intensity</strong></p><p>每单位立体角的power，发射</p><p>[W&#x2F;sr]</p><p>立体角可以理解为角度、弧度的3维扩展</p><p>立体角对应的球表面积&#x2F;半径平方</p><p><code>dA = (rdθ)(rsinθdφ) = r^2*sinθ*dθ*dφ</code> </p><p>微分立体角<code>dω=dA/r^2=sinθdθdφ</code></p><p>任意方向上辐射出的I</p><hr><p><strong>Irradiance</strong></p><p>单位面积接受到的power，接受</p><p><code>E(x)=dΦ(x)/dA</code></p><p>E&#x3D;Φ&#x2F;4πr<sup>2</sup></p><hr><p><strong>Radiance</strong></p><p>单位立体角单位投影面积的power</p><p>描述从某个面向某个方向辐射的能量</p><p>可以理解为每单位立体角的Irradiance或每单位面积的intensity</p><hr><p>radiance对所有方向求积分就是Irradiance</p><h2 id="双向反射分布函数BRDF"><a href="#双向反射分布函数BRDF" class="headerlink" title="双向反射分布函数BRDF"></a>双向反射分布函数BRDF</h2><p>描述表面Irradiance的反射分配，定义了不同的材质</p><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>物体的自发光+BRDF</p><p><code>L=E+KL</code></p><p>L&#x3D;E+KE+K<sup>2</sup>E+K<sup>3</sup>E+……</p><h2 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h2><p>一种求解定积分的方法，在原函数复杂不可求的情况下得出其结果</p><p>在积分区间内不断采样，用长方形的面积表示积分，最后对所有长方形的的面积求平均</p><p>$$<br>满足概率X_i-p(x)<br>$$<br>$$<br>\int f(x)dx&#x3D;\frac{1}{N}\sum^{N}_{i&#x3D;0}\frac{f(X_i)}{p(X_i)}<br>$$</p><h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>whitted-Style无法解决：多次反射和color bleeding</p><hr><p>直接光照：对渲染方程进行蒙特卡洛积分</p><p>间接光照：把物体当光源，回到直接光照</p><hr><p>光线弹射存在指数爆炸</p><ul><li>每个着色点打出<strong>一条</strong>光线，路径追踪</li></ul><hr><p><strong>俄罗斯轮盘赌(Russian Roulette,RR)</strong></p><p>路径递归问题，结束条件</p><p>以一定的概率p，shoot a ray and return the shading result divided by p:Lo&#x2F;p</p><p>再用1-p的概率不打光线，get 0</p><p>期望：<code>E=p*(Lo/p)+(1-p)*0=Lo</code></p><p>每次以一定概率打光线，能不能打光看运气</p><hr><p>均匀采样会有光线浪费问题</p><p>直接在光源上采样，完全不浪费</p><p>采样变两部分：光源直接照射和反射（用RR）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GAMES101-Ray-Tracing&quot;&gt;&lt;a href=&quot;#GAMES101-Ray-Tracing&quot; class=&quot;headerlink&quot; title=&quot;GAMES101-Ray Tracing&quot;&gt;&lt;/a&gt;GAMES101-Ray Tracing&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Graphics" scheme="http://example.com/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Games101-Rasterization(Antialiasing and Z-Buffer）笔记</title>
    <link href="http://example.com/2021/04/03/Games101-06-Rasterization%EF%BC%88Antialising%EF%BC%89/"/>
    <id>http://example.com/2021/04/03/Games101-06-Rasterization%EF%BC%88Antialising%EF%BC%89/</id>
    <published>2021-04-03T15:59:00.000Z</published>
    <updated>2023-09-12T10:23:35.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Games101-Rasterization（Antialiasing-and-Z-Buffer）"><a href="#Games101-Rasterization（Antialiasing-and-Z-Buffer）" class="headerlink" title="Games101-Rasterization（Antialiasing and Z-Buffer）"></a>Games101-Rasterization（Antialiasing and Z-Buffer）</h1><p>课堂收获的知识过多，无法全部记录在笔记中…只简单的记录一下大概</p><h2 id="走样和反走样"><a href="#走样和反走样" class="headerlink" title="走样和反走样"></a>走样和反走样</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>上节课通过判断每个 pixel 是否在三角形内得到的图形会出现很严重的锯齿状边缘，这就是一种走样（Aliasing）</p><p>走样（Aliasing）只有锯齿状一种吗？</p><ul><li>空间方面：摩尔纹，锯齿</li><li>时间方面：车轮效应</li></ul><hr><p>简单来说，产生走样的原因是：信号变化太快（数据量太大），采样跟不上（采集的数据少）</p><p>黑话：Artifact，指采样产生的各种误差和错误</p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>涉及信号处理和图像处理</p><p>首先提出一种可行方案：先将原图模糊再采样。效果确实比原先好，相当于在外围做了一圈渐变</p><p>两个步骤能调换次序吗？</p><hr><p><strong>基础知识引入</strong></p><p>傅里叶级数展开：任何周期函数，都可以表示成一系列 正弦+余弦+常数 的形式</p><p>傅里叶变换：时域$\rightarrow$频域，用于采样</p><p>逆傅里叶变换：频域$\rightarrow$时域，用于还原</p><hr><p>滤波：将特定频率过滤掉</p><p><strong>分析一张黑白照片</strong></p><p>（频率信息分布图？忘了）中心白色（低频信号），周围黑色（高频信号），有白色十字线（上下左右默认n张图片连续重叠，变化趋缓）</p><p>用高通滤波（High-pass filter）和低通滤波（Low-pass filter）处理图像后，发现高频表示边缘（怎么定义边缘？），低频表示变化平缓的区域</p><p>对于彩色图像则是在 RGB 三个通道上判断</p><hr><p><strong>如何滤波</strong></p><p>Filter &#x3D; Convolution（卷积，直观理解为平均化和模糊处理）</p><p>将某位置信号和周围信号通过一个滤波窗口加权平均</p><p>时域乘积 &#x3D; 频域卷积（还没搞懂）</p><p>box fliter：a n*n low-pass fliter</p><p>box越大越模糊，参与平均的位置越多</p><hr><p>采样</p><p>整个过程是：频谱 $\rightarrow$ 采样 $\rightarrow$ 重复原始信号频谱</p><p>使用冲击函数取样</p><p>如果冲击函数的频率不够，则时间间隔变小，采样复原出的函数每个周期就会出现交叉，产生混叠，从而出现走样</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>反走样</p><p>模糊（low-pass）在做什么？ 将函数的交叉部分去掉，得到没有交叉的函数</p><p>然后再采样</p><hr><p><strong>更准确的灰度值（色彩值）</strong></p><p>MSAA（MultiSampling Anti-Aliasing，多重采样抗锯齿） ：当前分辨率成倍提高，然后再把画缩放到当前的显示器上。只是寻找出物体边缘部分的像素，忽略掉了不会产生锯齿的内部像素</p><p>SSAA（SuperSampling Anti-Aliasing，超级采样抗锯齿）：在 1pixel 范围内加入假象的 n*n 个均匀分布定位点，提高覆盖率的准确度，但是计算量是原先的 n<sup>2</sup> 倍</p><p>但实际使用时用了各种优化手段，例如不均匀分布等减少来计算量，所以帧数不会下降太剧烈</p><h3 id="目前-Antialiasing-方法"><a href="#目前-Antialiasing-方法" class="headerlink" title="目前 Antialiasing 方法"></a>目前 Antialiasing 方法</h3><p>工业上：</p><ul><li>FXAA（Fast Approximate Anti-Aliasing，快速近似抗锯齿）：图像层面，先得到有锯齿图像，再在图像上直接处理</li><li>TAA（Temporal Anti-Aliasing，时间性抗锯齿）：运用上一几帧的信息，最常用的图像增强算法之一。</li><li>TXAA（Temporal Multi-Sample Anti-Aliasing）：TAA+MSAA</li><li>DLSS（Deep Learning Super Sampling）：基于深度学习的超采样</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>三角形之间会有遮挡关系</p><p>painter‘s Algorithm：对图像从后往前排序</p><p>但存在图形互相交叠的情况</p><hr><p><strong>z-Buffer（深度缓存）</strong></p><p>对每一个像素排序，记录每一个像素最浅的深度信息</p><p>生成结果最终图像（frame buffer）的同时生成深度图（depth buffer，z-buffer）</p><p>处理流程：记录每个 pixel 的深度，遇到更浅的深度时，画上去同时更新深度图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始 z 值为比任意点要深的值*/</span></span><br><span class="line"><span class="keyword">for</span>(each triangle T)</span><br><span class="line">    <span class="keyword">for</span>(each <span class="built_in">sample</span>(x,y,z) in T)</span><br><span class="line">        <span class="keyword">if</span>(z &lt; zbuffer[x,y])</span><br><span class="line">            framebuffer[x,y] = rgb;<span class="comment">//更新帧缓存</span></span><br><span class="line">            zbuffer[x,y] = z;<span class="comment">//更新深度图</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><hr><p>复杂度</p><p>O（n）</p><hr><p>zbuffer无法处理透明物体</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Games101-Rasterization（Antialiasing-and-Z-Buffer）&quot;&gt;&lt;a href=&quot;#Games101-Rasterization（Antialiasing-and-Z-Buffer）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Graphics" scheme="http://example.com/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>glad、glfw配置</title>
    <link href="http://example.com/2021/03/21/opengl/"/>
    <id>http://example.com/2021/03/21/opengl/</id>
    <published>2021-03-21T07:54:16.000Z</published>
    <updated>2023-09-13T06:32:39.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="glad、glfw配置，VS-2019"><a href="#glad、glfw配置，VS-2019" class="headerlink" title="glad、glfw配置，VS 2019"></a>glad、glfw配置，VS 2019</h1><p>原文参考 &gt;&gt; <a href="https://learnopengl.com/Getting-started/Creating-a-window">https://learnopengl.com/Getting-started/Creating-a-window</a></p><p>中文版参考 &gt;&gt; <a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/">https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/</a></p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>下载glfw</p><p><a href="https://www.glfw.org/download.html">下载地址</a></p><p>一般解压至项目文件夹</p><p>链接</p><p>解决方案资源管理器 <strong>右键 &gt;&gt; 属性 &gt;&gt; VC++目录</strong></p><ul><li>包含目录 添加 include 文件夹路径</li><li>库目录 添加 lib 文件夹路径</li></ul><p><img src="/iimmgg/2021321-172822.jpg" alt="0"></p><p>链接器</p><p>附加依赖项：手动输入<code>glfw3.lib;opengl32.lib</code></p><p><img src="/iimmgg/2021321-212507.jpg" alt="2021321-212507"></p><p>这时就可以在cpp文件中加入<code>#include &lt;GLFW/glfw3.h&gt;</code></p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>glad提供在线服务 <a href="https://glad.dav1d.de/">https://glad.dav1d.de/</a></p><ul><li>Language：C&#x2F;C++</li><li>API gl 选择版本大于等于之前 glfw 版本的选项</li><li>Profile 选择 Core</li><li>勾选 Generate a loader</li></ul><p>生成，下载zip文件，获得两个包含头文件的文件夹和一个<code>glad.c</code>文件</p><p>包含头文件的文件夹放入 glfw 的 include 下，glad.c 也放入项目中</p><p><img src="/iimmgg/2021321-213003.jpg" alt="2021321-213003"></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功获得一个如下图窗口，可通过Esc关闭</p><p><img src="/iimmgg/2021321-212635.jpg" alt="2021321-212635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;glad、glfw配置，VS-2019&quot;&gt;&lt;a href=&quot;#glad、glfw配置，VS-2019&quot; class=&quot;headerlink&quot; title=&quot;glad、glfw配置，VS 2019&quot;&gt;&lt;/a&gt;glad、glfw配置，VS 2019&lt;/h1&gt;&lt;p&gt;原文</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Graphics" scheme="http://example.com/tags/Graphics/"/>
    
  </entry>
  
  <entry>
    <title>基于离散对数的公钥加密</title>
    <link href="http://example.com/2020/12/13/DL/"/>
    <id>http://example.com/2020/12/13/DL/</id>
    <published>2020-12-13T06:41:15.000Z</published>
    <updated>2023-09-13T06:30:31.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于离散对数的公钥加密"><a href="#基于离散对数的公钥加密" class="headerlink" title="基于离散对数的公钥加密"></a>基于离散对数的公钥加密</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random                   </span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number         </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GenPara</span>(<span class="params">bitlen</span>):</span><br><span class="line">q = number.getPrime(bitlen-<span class="number">1</span>) </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">not</span> number.isPrime(<span class="number">2</span> * q + <span class="number">1</span>)):</span><br><span class="line">q = number.getPrime(bitlen-<span class="number">1</span>) </span><br><span class="line">p = <span class="number">2</span> * q + <span class="number">1</span>         <span class="comment"># generate safe prime p = 2 \* q + 1    </span></span><br><span class="line">    g = random.randint(<span class="number">0</span>, p-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span>(fastPowMod(g, <span class="number">2</span>, p) == <span class="number">1</span> <span class="keyword">or</span> fastPowMod(g, q, p) == <span class="number">1</span>):</span><br><span class="line">g = random.randint(<span class="number">0</span>, p-<span class="number">1</span>)  <span class="comment"># generate the primitive element g</span></span><br><span class="line"><span class="keyword">return</span> p, q, g </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fastPowMod</span>(<span class="params">b,n,m</span>):         <span class="comment"># 快速模幂</span></span><br><span class="line">      b = b % m</span><br><span class="line">      a = <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (n):</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>:                 </span><br><span class="line">            a = (a * b) % m                   </span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>                   </span><br><span class="line">        b = (b * b) % m</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GenKey</span>(<span class="params">p, g</span>):</span><br><span class="line">      x = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)</span><br><span class="line">      y = fastPowMod(g, x, p)</span><br><span class="line">      <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Enc</span>(<span class="params">m, p, g, y</span>):</span><br><span class="line">      k = random.randint(<span class="number">1</span>, p-<span class="number">2</span>)</span><br><span class="line">      u = fastPowMod(g, k, p)</span><br><span class="line">      v = fastPowMod(y, k, p)* m % p</span><br><span class="line">      <span class="keyword">return</span> [u, v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dec</span>(<span class="params">c, p, x</span>):</span><br><span class="line">      u = c[<span class="number">0</span>]</span><br><span class="line">      v = c[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">return</span> fastPowMod(u,p-<span class="number">1</span>-x,p)* v % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Round1</span>(<span class="params">x1, p, g</span>):</span><br><span class="line">  <span class="keyword">return</span> fastPowMod(g, x1, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Round2</span>(<span class="params">x2, p, g</span>):</span><br><span class="line">  <span class="keyword">return</span> fastPowMod(g, x2, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FinalRound</span>(<span class="params">x1, y1, x2, y2, p</span>):</span><br><span class="line">  <span class="keyword">return</span> fastPowMod(y2, x1, p) , fastPowMod(y1, x2, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">[p, q, g] = GenPara(<span class="number">256</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;p = %d\ng = %d&quot;</span> %(p, g))   </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nElgamal: &quot;</span>)</span><br><span class="line">      [x, y] = GenKey(p, g)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nx = %d\ny = %d&quot;</span> %(x, y))  </span><br><span class="line">      m = random.randint(<span class="number">0</span>, p-<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nm   = %d&quot;</span> %m)</span><br><span class="line">      c = Enc(m, p, g, y)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nc = %s&quot;</span> %c)</span><br><span class="line">      m_dec = Dec(c, p, x)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nm_dec = %d&quot;</span> %m_dec)</span><br><span class="line">      <span class="built_in">print</span>(m == m_dec)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nDH key exchange: &quot;</span>)</span><br><span class="line">      x1 = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)  </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nAlice chooses x1 = %d&quot;</span> %x1)</span><br><span class="line">      y1 = Round1(x1, p, g)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nAlice sends %d to Bob&quot;</span> %y1)</span><br><span class="line">      x2 = random.randint(<span class="number">1</span>, p-<span class="number">1</span>)  </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nBob chooses x2 = %d&quot;</span> %x2)</span><br><span class="line">      y2 = Round2(x2, p, g)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nBob sends %d to Alice&quot;</span> %y2)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\nAlice and Bob agree with the same key: &quot;</span>)</span><br><span class="line">      [z1, z2] = FinalRound(x1, y1, x2, y2, p)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%d\n%d&quot;</span> %(z1,z2))</span><br><span class="line">      <span class="built_in">print</span>(z1 == z2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于离散对数的公钥加密&quot;&gt;&lt;a href=&quot;#基于离散对数的公钥加密&quot; class=&quot;headerlink&quot; title=&quot;基于离散对数的公钥加密&quot;&gt;&lt;/a&gt;基于离散对数的公钥加密&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>shyo密码管理器开发日志0x03</title>
    <link href="http://example.com/2020/12/09/shyo-3/"/>
    <id>http://example.com/2020/12/09/shyo-3/</id>
    <published>2020-12-09T07:22:39.000Z</published>
    <updated>2023-09-13T06:33:56.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shyo密码管理器开发日志0x03"><a href="#shyo密码管理器开发日志0x03" class="headerlink" title="shyo密码管理器开发日志0x03"></a>shyo密码管理器开发日志0x03</h1><ul><li>之前实现的只是，参数传递和数据库存取数据，现在想把这个弄成一个api接口方便前端使用</li></ul><p>servlet-api.jar</p><p>api_test.java</p><p>编译时报错：<code>package javax.servlet does not exist</code>和<code>package javax.servlet.http does not exist</code></p><p><code>javac -cp /usr/local/apache-tomcat-10.0.0-M10/lib/servlet-api.jar api_test.java</code></p><p><code>-cp</code>是<code>-classpath</code>的缩写(<code>javac --help</code>查看细节)</p><p>api_test.class</p><p>爆了爆了，服务器的问题怎么也解决不了，我还没存快照。。。，系统回滚了，重配</p><p>发现可以通过HTML+Ajax实现服务端和前端只通过json格式传输数据，那就这么做吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shyo密码管理器开发日志0x03&quot;&gt;&lt;a href=&quot;#shyo密码管理器开发日志0x03&quot; class=&quot;headerlink&quot; title=&quot;shyo密码管理器开发日志0x03&quot;&gt;&lt;/a&gt;shyo密码管理器开发日志0x03&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;之前实现</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>shyo密码管理器开发日志0x02</title>
    <link href="http://example.com/2020/12/08/shyo-2/"/>
    <id>http://example.com/2020/12/08/shyo-2/</id>
    <published>2020-12-08T07:26:36.000Z</published>
    <updated>2023-09-13T06:33:34.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shyo密码管理器开发日志0x02"><a href="#shyo密码管理器开发日志0x02" class="headerlink" title="shyo密码管理器开发日志0x02"></a>shyo密码管理器开发日志0x02</h1><ul><li>使用vsc的ssh扩展连接服务器体验再次起飞</li><li>服务器获取用户名和密码</li><li>从数据库中查询数据</li></ul><h2 id="测试页面需要的功能"><a href="#测试页面需要的功能" class="headerlink" title="测试页面需要的功能"></a>测试页面需要的功能</h2><p>index.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--登陆表单--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;success.jsp&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;userName&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Please input userName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;userPassword&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Please input userPassword&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>success.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;success&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);<span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pass</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userPassword&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;name:&lt;/h1&gt;&quot;</span> + name);</span><br><span class="line">        out.print(<span class="string">&quot;&lt;h1&gt;password:&lt;/h1&gt;&quot;</span> + pass);</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这会有编码问题，但都是小问题</p><h2 id="图形化界面管理数据库"><a href="#图形化界面管理数据库" class="headerlink" title="图形化界面管理数据库"></a>图形化界面管理数据库</h2><p>为了方便管理数据库</p><p>然后尝试了整整一下午！各种报错，晚上终于解决了，在最后会贴出解决方法（注意：我是轻量应用服务器，如果你是ECS的话直接百度就完事了）</p><p>连上去之后参考这个修改用户权限：<a href="http://c.biancheng.net/view/7249.html">http://c.biancheng.net/view/7249.html</a></p><p>记得在服务器控制台开放3306端口</p><p>由于是项目所以就新建了一个用户</p><p><code>GRANT ALL PRIVILEGES ON *.* TO &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;****&#39; WITH GRANT OPTION; </code></p><p>第一个<code>*</code>意味着操纵任意数据库权限，第二个<code>*</code>表示操纵任意数据表权限，<code>shyo</code>是用户名，<code>%</code>为任意IP地址登陆（host）的通配符，<code>****</code>填密码</p><p>刷新权限：<code>FLUSH PRIVILEGES; </code></p><p>用各种MySQL图形化管理工具一连就可（当然你也可以直接连root用户，记得修改root的host为你需要连的IP或%）</p><p>创建数据库</p><p><img src="C:\Users\13240\Desktop\2020128-211117.jpg" alt="2020128-211117"></p><p>测试用数据库设计</p><p><code>用户 | 描述文字 | url | password</code></p><p><img src="C:\Users\13240\Desktop\2020128-213945.jpg" alt="2020128-213945"></p><p>采用utf-8编码    UTF-8：一个汉字＝3个字节      GBK：一个汉字＝2个字节</p><p>url设置255是不清楚会不会存在一些base64解析后的超长url，password限制长度，但这也是一个测试用所以就随便一点了</p><h2 id="jsp连接数据库"><a href="#jsp连接数据库" class="headerlink" title="jsp连接数据库"></a>jsp连接数据库</h2><p><strong>需要使用JDBC驱动</strong></p><p>我去Tomcat的lib下看了一眼过然没有，那就自己装，本地下载jar文件后传到服务器中，放到<code>/usr/local/apache-tomcat-10.0.0-M10/lib</code>下</p><p>菜鸟上下的MySQL 5版本：<a href="http://static.runoob.com/download/mysql-connector-java-5.1.39-bin.jar">mysql-connector-java-5.1.39-bin.jar</a>，扔到服务器上（MySQL8配炸了用不来）</p><p>给权限<code>sudo chmod 755 mysql-connector-java-5.1.39.jar</code>，放到上面的lib文件夹下</p><p>在项目文件夹下创建sqlTest.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;通过JSP打开数据表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"> &lt;%   </span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <span class="comment">//驱动程序名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/password_test&quot;</span>; <span class="comment">//数据库名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;shyo&quot;</span>;  <span class="comment">//数据库用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;  <span class="comment">//数据库用户密码 </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);  <span class="comment">//连接状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;  </span><br><span class="line">            out.print(<span class="string">&quot;数据库连接成功！&quot;</span>);  </span><br><span class="line">            out.print(<span class="string">&quot;&lt;br /&gt;&quot;</span>);            </span><br><span class="line">            <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM test;&quot;</span>;  <span class="comment">//查询语句</span></span><br><span class="line">            stmt = conn.createStatement();  </span><br><span class="line">            rs = stmt.executeQuery(sql);  </span><br><span class="line">            out.print(<span class="string">&quot;查询结果：&quot;</span>);  </span><br><span class="line">            out.print(<span class="string">&quot;&lt;br /&gt;&quot;</span>);  </span><br><span class="line">            out.println(<span class="string">&quot;姓名&quot;</span>+<span class="string">&quot;  &quot;</span>+<span class="string">&quot;url&quot;</span>+<span class="string">&quot;  &quot;</span>+<span class="string">&quot;密码&quot;</span>);  </span><br><span class="line">            out.print(<span class="string">&quot;&lt;br /&gt;&quot;</span>);  </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;  </span><br><span class="line">                out.println(rs.getString(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot; &quot;</span>+rs.getString(<span class="string">&quot;url&quot;</span>)+<span class="string">&quot; &quot;</span>+rs.getString(<span class="string">&quot;password&quot;</span>)+<span class="string">&quot;&lt;br /&gt;&quot;</span>); <span class="comment">//将查询结输出  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            out.print(<span class="string">&quot;连接失败！&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">%&gt;   </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>报错<code>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</code></p><p>查了一下需要配置tomcat的连接池，在 apache-tomcat-10.0.0-M10&#x2F;conf&#x2F;server.xml下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个标签是已经存在的，找到它然后编辑即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">&lt;!--配置mysql数据库的连接池, 需要做的额外步骤是将mysql的Java驱动类放到tomcat的lib目录下--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;jdbc/mysqlds&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">username</span>=<span class="string">&quot;shyo&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">maxIdle</span>=<span class="string">&quot;30&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">maxWait</span>=<span class="string">&quot;10000&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">maxActive</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">driverClassName</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"> <span class="comment">&lt;!--test位置放你的数据库名--&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后去conf&#x2F;context.xml加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ResourceLink</span> <span class="attr">name</span>=<span class="string">&quot;jdbc/mysqlds&quot;</span> <span class="attr">global</span>=<span class="string">&quot;jdbc/mysqlds&quot;</span> <span class="attr">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>ROOT/项目文件夹</code>下添加<code>web.xml</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>mysql数据库连接池<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>jdbc/mysqlds<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>javax.sql.DataSource<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-auth</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">res-auth</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-sharing-scope</span>&gt;</span>Shareable<span class="tag">&lt;/<span class="name">res-sharing-scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后重启tomcat！！！！！！！！一定要重启一下！！！！！！！</p><p>然后芜湖，连上了</p><p>至此，文件结构简单的一批</p><p><img src="C:\Users\13240\Desktop\2020129-03729.jpg" alt="2020129-03729"></p><h2 id="Linux关于MySQL远程登陆的问题"><a href="#Linux关于MySQL远程登陆的问题" class="headerlink" title="Linux关于MySQL远程登陆的问题"></a>Linux关于MySQL远程登陆的问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shyo密码管理器开发日志0x02&quot;&gt;&lt;a href=&quot;#shyo密码管理器开发日志0x02&quot; class=&quot;headerlink&quot; title=&quot;shyo密码管理器开发日志0x02&quot;&gt;&lt;/a&gt;shyo密码管理器开发日志0x02&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用vs</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>shyo密码管理器开发 0x01</title>
    <link href="http://example.com/2020/12/06/shyo-1/"/>
    <id>http://example.com/2020/12/06/shyo-1/</id>
    <published>2020-12-06T12:18:53.000Z</published>
    <updated>2023-09-13T06:33:20.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shyo密码管理器开发日志-0x01"><a href="#shyo密码管理器开发日志-0x01" class="headerlink" title="shyo密码管理器开发日志 0x01"></a>shyo密码管理器开发日志 0x01</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前言：9月开学到现在12月，想了各种密码管理器的实现方法，有思考纯前端实现密码存单独文件或存在本地数据库中，也有关联服务器的，期间也写了不少代码，但都没有一个很大的进展，在和老师的谈论中逐步理清大体框架，主要是实现一个密码存在服务端用以多端同步，用protobuf传输数据，并在前端加以处理的框架（一直觉得密码一旦在网络中传输就会有各种安全问题，这些都是需要解决的问题，由于我们的目标是基于OTP的密码管理器，所以这说不定是一个解决方案）。</p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><ul><li><p>由于是多人开发，我就整了一个服务器（阿里云学生认证）（终于有自己的服务器辣，后面准备把博客迁移到服务器上），到时候开放一个端口供前端开发使用</p></li><li><p>准备使用之前有尝试过的TomCat和MySQL搭建JAVA后端</p></li><li><p>数据传输使用的是protobuf</p></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>当场在阿里云买了（虽然腾讯云好像更便宜，但在杭州没有站点）轻量应用服务器(和ECS有点区别但影响不大)，用的是系统镜像ubuntu18.04，然后ssh就能连了，起飞，爽到</p><h2 id="安装JDK-TomCat"><a href="#安装JDK-TomCat" class="headerlink" title="安装JDK+TomCat"></a>安装JDK+TomCat</h2><p><code>sudo apt install openjdk-11-jdk-headless</code>安装JDK（TomCat需要JDK）</p><hr><p>安装TomCat</p><p><a href="https://tomcat.apache.org/%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81">https://tomcat.apache.org/下载源码</a></p><p><img src="/./20201206230311.png" alt="20201206230311"></p><p>Window打开一个新的终端，用<code>scp 被上传文件路径 上传服务器IP:/home/存在的路径</code>上传</p><p>解压<code>tar -zxvf apache-tomcat-10.0.0-M10.tar.gz</code></p><p>改权限<code>sudo chmod 755 -R apache-tomcat-10.0.0-M10</code></p><p>移动<code>sudo mv apache-tomcat-10.0.0-M10 /usr/local</code></p><p>修改文件<code>cd /usr/local/apache-tomcat-10.0.0-M10/bin</code></p><p><code>sudo vi startup.sh</code></p><p>按<code>i</code>开始编辑</p><p>文件最后加入（可能还要加一个有关jdk的，但我这不用加我也不知道为啥）</p><p><img src="/./20201206231144.png" alt="20201206231144"></p><p><code>Esc</code>退出编辑模式，<code>:wq</code>保存并退出</p><p>然后<code>sudo ./startup.sh</code>，访问<code>公网IP:8080</code>即可</p><p><img src="/./20201206232442.png" alt="20201206232442"></p><p>关闭服务是<code>sudo ./shutdown.sh</code></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><code>sudo apt-get update</code></p><hr><p>安装<code>sudo apt-get install mysql-server</code></p><p><code>sudo mysql -uroot -p</code>初始root密码为空，直接Enter</p><hr><p><strong>设置root密码</strong></p><p><code>use mysql;</code>   </p><p><code>update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where user=&#39;root&#39;;</code> </p><p><code>update user set plugin=&quot;mysql_native_password&quot;;</code>   </p><p><code>flush privileges;</code>   </p><p><code>quit;</code></p><hr><p><strong>添加用户</strong></p><p><code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code></p><p>username：用户名<br>host：指定该用户在哪个主机上可以登陆，本地用户用localhost，从任意远程主机登陆，可以使用通配符%<br>password：用户密码</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>管理器服务端涉及到MySQL和Tomcat，配置怎么说呢个人感觉还是很方便的（以前用其他系统装简直人间疾苦），这次至少一路绿灯过来的。</p><p>接下来就是尝试链接数据库，实现前后端的数据传输服务（也许会用到servlet），然后protobuf也要进一步研究了</p><p>然后有自己的服务器了撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shyo密码管理器开发日志-0x01&quot;&gt;&lt;a href=&quot;#shyo密码管理器开发日志-0x01&quot; class=&quot;headerlink&quot; title=&quot;shyo密码管理器开发日志 0x01&quot;&gt;&lt;/a&gt;shyo密码管理器开发日志 0x01&lt;/h1&gt;&lt;h2 id=&quot;前</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>rsa加解密（python实现）</title>
    <link href="http://example.com/2020/11/30/rsa/"/>
    <id>http://example.com/2020/11/30/rsa/</id>
    <published>2020-11-30T05:01:34.000Z</published>
    <updated>2023-09-13T06:33:03.277Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random                                     <span class="comment"># import random to use randint </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number                    <span class="comment"># import Crypto.Util.number to use getPrime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exgcd</span>(<span class="params">r0, r1</span>):<span class="comment"># 扩展欧几里得算法</span></span><br><span class="line">    s0, s1 = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    t0, t1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    q, r = r0 // r1, r0 % r1</span><br><span class="line">    <span class="keyword">while</span> (r):</span><br><span class="line">        s, t = s0 - q * s1, t0 - q * t1  </span><br><span class="line">        s0, s1, t0, t1 = s1, s, t1, t</span><br><span class="line">        r0, r1 = r1, r</span><br><span class="line">        q, r = r0 // r1, r0 % r1</span><br><span class="line">    <span class="keyword">return</span> s1, t1, r1 </span><br><span class="line">                              </span><br><span class="line">count = <span class="number">1</span>                                   <span class="comment">#  count = number of divisions</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">A, B</span>):                         <span class="comment">#  Euclidean Algorithm, compute gcd(A, B) </span></span><br><span class="line">    <span class="keyword">if</span> A % B == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> B</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    r = A % B</span><br><span class="line">    <span class="keyword">return</span> gcd(B, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GenKey</span>(<span class="params">bitlen</span>):                               <span class="comment"># 生成密钥对</span></span><br><span class="line">    p = number.getPrime(bitlen)                   <span class="comment"># generate prime p</span></span><br><span class="line">    q = number.getPrime(bitlen)                   <span class="comment"># generate prime q</span></span><br><span class="line">    n = p * q                                     <span class="comment"># n = p * q</span></span><br><span class="line">    phi_n = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)                         <span class="comment"># phi_n = (p-1) * (q-1)</span></span><br><span class="line">    e = random.randint(<span class="number">0</span>, phi_n - <span class="number">1</span>)              <span class="comment"># randomly choose e</span></span><br><span class="line">    <span class="keyword">while</span> (gcd(e, phi_n) != <span class="number">1</span>):                   <span class="comment"># if gcd(e, phi_n) != 1    </span></span><br><span class="line">        e = random.randint(<span class="number">0</span>, phi_n - <span class="number">1</span>)          <span class="comment"># choose e again </span></span><br><span class="line">    [d, k, r] = Exgcd(e, phi_n)                   <span class="comment"># use Exgcd(e, phi_n) to compute d</span></span><br><span class="line">    d = d % phi_n                                 <span class="comment"># d = d % phi_n</span></span><br><span class="line">    <span class="keyword">return</span> n, e, d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fastPowMod</span>(<span class="params">b,n,m</span>):<span class="comment"># 快速模逆</span></span><br><span class="line">    b = b % m</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (n):</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>:                                 </span><br><span class="line">            a = (a * b) % m                                     </span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>                                      </span><br><span class="line">        b = (b * b) % m</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Enc</span>(<span class="params">m, e, n</span>):</span><br><span class="line">    <span class="keyword">return</span> fastPowMod(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dec</span>(<span class="params">c, d, n</span>):</span><br><span class="line">    <span class="keyword">return</span> fastPowMod(c, d, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_to_int</span>(<span class="params">s</span>):</span><br><span class="line">        b = <span class="built_in">str</span>.encode(s)                    <span class="comment"># str to bytes</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(b, <span class="string">&#x27;big&#x27;</span>)      <span class="comment"># bytes to int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int_to_str</span>(<span class="params">i, str_len</span>):              <span class="comment"># str_len is the length of str converted</span></span><br><span class="line">    b = i.to_bytes(str_len, <span class="string">&#x27;big&#x27;</span>)       <span class="comment"># convert int to bytes </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>.decode(b)               <span class="comment"># convert bytes to str </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:                        <span class="comment"># main function</span></span><br><span class="line">    [n, e, d] = GenKey(<span class="number">512</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nn = %d\ne = %d\nd = %d\n&quot;</span> %(n,e,d))  <span class="comment"># print n, e, d</span></span><br><span class="line">    m = <span class="built_in">input</span>(<span class="string">&quot;Input m(digits): &quot;</span>)                <span class="comment"># input the message m(数字形式)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n    m = %s\n&quot;</span> %m)                    <span class="comment"># print m </span></span><br><span class="line">    c = Enc(<span class="built_in">int</span>(m),e,n)                           <span class="comment"># encrypt m </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c = %d\n&quot;</span> %c)                          <span class="comment"># print the ciphertext c</span></span><br><span class="line">    m_dec = Dec(c,d,n)                            <span class="comment"># decrypt c</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;m_dec = %d\n&quot;</span> %m_dec)                  <span class="comment"># print the decrypted message m_dec</span></span><br><span class="line">    <span class="built_in">print</span>( <span class="built_in">int</span>(m) == m_dec )</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">input</span>(<span class="string">&quot;Input m(string): &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n    m = %s\n&quot;</span> %m)</span><br><span class="line">    m_len = <span class="built_in">len</span>(m)</span><br><span class="line">    c = Enc(str_to_int(m),e,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c = %s\n&quot;</span> %c)</span><br><span class="line">    m_dec = Dec(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;m_dec = %s\n&quot;</span> %int_to_str(m_dec,m_len))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Windows Form编程</title>
    <link href="http://example.com/2020/11/13/WinFrom/"/>
    <id>http://example.com/2020/11/13/WinFrom/</id>
    <published>2020-11-13T02:58:00.000Z</published>
    <updated>2023-09-13T06:34:47.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-Form编程-Ⅰ"><a href="#Windows-Form编程-Ⅰ" class="headerlink" title="Windows Form编程  Ⅰ"></a>Windows Form编程  Ⅰ</h1><h2 id="代码执行机制"><a href="#代码执行机制" class="headerlink" title="代码执行机制"></a>代码执行机制</h2><p>两个关键词：事件驱动，被动</p><hr><p>不同于控制台应用的开始运行直到结束，或是等待用户输入，WinForm是由<strong>事件驱动</strong>的。用户使用时会产生诸如键盘输入，鼠标点击，鼠标移动等等一系列的事件，通过捕获其中一部分有用的事件进行响应</p><ul><li><strong>被动</strong>执行</li><li>需要考虑各种可能的用户输入（各种事件），对其中特殊情况做出针对性的处理</li><li>消息循环机制：等待消息 - 获取消息 - 处理消息 - 等待消息</li></ul><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>vs新建Windows 窗体应用(.NET Framework)</p><p><img src="/./img/01.jpg" alt="1"></p><p>选中自动生成的Form1，右键属性或F7可以查看控件代码</p><p>（控件可以包含其他控件，现在这个控件可以理解成将在内部添加的控件的父控件）</p><p><img src="/./img/02.jpg" alt="2"></p><p>可以看到Form1继承自Form，并有一个<code>partial</code>修饰，表示当前的代码只是Form1的一部分</p><p>Form1的另一部分代码位于<code>Form1.Designer.cs</code>，可以在sln视图下找到</p><p><img src="/./img/03.jpg" alt="3"></p><p>这部分代码会根据设计视图下的操作<strong>自动改变</strong>，不需要自行编辑（自行编辑就  危）</p><hr><p>此时程序已经可以运行了，生成一个空白窗口</p><h2 id="子控件的添加和对需要响应事件的添加"><a href="#子控件的添加和对需要响应事件的添加" class="headerlink" title="子控件的添加和对需要响应事件的添加"></a>子控件的添加和对需要响应事件的添加</h2><p>从工具箱中选取控件拖拽至父窗口，调整大小位置</p><p><img src="/./img/04.jpg" alt="4"></p><p>此时可以发现<code>Form1.Designer.cs</code>已经自动生成了对应的控件</p><p><img src="/./img/05.jpg" alt="5"></p><p>添加事件选择闪电图标进入预定义的事件列表</p><p>双击需要生成的事件</p><p><img src="/./img/06.jpg" alt="6"></p><p><img src="/./img/07.jpg" alt="7"></p><p>此时在<code>Form1.cs</code>中生成对应的事件</p><p><img src="/./img/08.jpg" alt="8"></p><p>注意Form1.cs<code>中的方法在设计视图下可以不用，但如果设计设图中的事件和</code>Form1.cs&#96;中的不同会无法显示图形界面，所以<strong>事件处理函数改名请在闪电事件列表中操作</strong></p><hr><p>之后就是开发事件处理逻辑和控价的各种属性调整了，这里暂且不讲</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-Form编程-Ⅰ&quot;&gt;&lt;a href=&quot;#Windows-Form编程-Ⅰ&quot; class=&quot;headerlink&quot; title=&quot;Windows Form编程  Ⅰ&quot;&gt;&lt;/a&gt;Windows Form编程  Ⅰ&lt;/h1&gt;&lt;h2 id=&quot;代码执行机制&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>公钥加密数学基础-欧几里得算法</title>
    <link href="http://example.com/2020/11/02/EEA/"/>
    <id>http://example.com/2020/11/02/EEA/</id>
    <published>2020-11-02T09:05:06.000Z</published>
    <updated>2023-09-13T06:30:46.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公钥密码的数学基础-欧几里得算法"><a href="#公钥密码的数学基础-欧几里得算法" class="headerlink" title="公钥密码的数学基础 - 欧几里得算法"></a>公钥密码的数学基础 - 欧几里得算法</h1><h2 id="标准算法"><a href="#标准算法" class="headerlink" title="标准算法"></a>标准算法</h2><p>一般用来算两个整数的公因数</p><p>即使在大数求公因数时也极其高效</p><ul><li>另一个耳熟能详的名字辗转相除法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#欧几里得算法</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Euclidean</span>(<span class="params">A,B</span>):</span><br><span class="line">    <span class="keyword">if</span> A % B == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> B</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    r = A % B</span><br><span class="line">    <span class="keyword">return</span> Euclidean(B, r)</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>用来算模逆元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#扩展欧几里得算法</span></span><br><span class="line"><span class="keyword">global</span> ls</span><br><span class="line"><span class="keyword">global</span> lt</span><br><span class="line">ls = [<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">lt = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">s = t = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">EEA</span>(<span class="params">A,B</span>):</span><br><span class="line">    <span class="keyword">if</span> A % B == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    r = A % B</span><br><span class="line">    q = A // B</span><br><span class="line">    <span class="keyword">global</span> s</span><br><span class="line">    s = ls[<span class="number">0</span>] - q*ls[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">global</span> t</span><br><span class="line">    t = lt[<span class="number">0</span>] - q*lt[<span class="number">1</span>]</span><br><span class="line">    ls[<span class="number">0</span>],ls[<span class="number">1</span>] = ls[<span class="number">1</span>],s</span><br><span class="line">    lt[<span class="number">0</span>],lt[<span class="number">1</span>] = lt[<span class="number">1</span>],t</span><br><span class="line">    <span class="keyword">return</span> EEA(B,r)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公钥密码的数学基础-欧几里得算法&quot;&gt;&lt;a href=&quot;#公钥密码的数学基础-欧几里得算法&quot; class=&quot;headerlink&quot; title=&quot;公钥密码的数学基础 - 欧几里得算法&quot;&gt;&lt;/a&gt;公钥密码的数学基础 - 欧几里得算法&lt;/h1&gt;&lt;h2 id=&quot;标准算法&quot;</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>
